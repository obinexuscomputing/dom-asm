{"version":3,"file":"index.umd.js","sources":["../src/tokenizer/index.ts","../src/ast/index.ts","../src/validator/index.ts","../src/optimizer/index.ts","../src/generator/index.ts","../src/parser/index.ts"],"sourcesContent":["export type Token = {\r\n  type: string; // e.g., 'selector', 'property', 'value', 'whitespace', 'comment', 'delimiter'\r\n  value: string; // The actual content of the token\r\n  position: { line: number; column: number }; // For error reporting and debugging\r\n};\r\n\r\nexport class CSSTokenizer {\r\n  private input: string;\r\n  private position: number;\r\n  private line: number;\r\n  private column: number;\r\n\r\n  constructor(input: string) {\r\n    this.input = input;\r\n    this.position = 0;\r\n    this.line = 1;\r\n    this.column = 1;\r\n  }\r\n\r\n  private isWhitespace(char: string): boolean {\r\n    return char === ' ' || char === '\\t' || char === '\\n' || char === '\\r';\r\n  }\r\n\r\n  private isCommentStart(): boolean {\r\n    return this.input[this.position] === '/' && this.input[this.position + 1] === '*';\r\n  }\r\n\r\n  private isDelimiter(char: string): boolean {\r\n    return ['{', '}', ':', ';', ','].includes(char);\r\n  }\r\n\r\n  private consumeWhitespace(): void {\r\n    while (this.isWhitespace(this.input[this.position])) {\r\n      if (this.input[this.position] === '\\n') {\r\n        this.line++;\r\n        this.column = 1;\r\n      } else {\r\n        this.column++;\r\n      }\r\n      this.position++;\r\n    }\r\n  }\r\n\r\n  private consumeComment(): Token {\r\n    const start = this.position;\r\n    this.position += 2; // Skip '/*'\r\n    while (\r\n      this.position < this.input.length &&\r\n      !(this.input[this.position] === '*' && this.input[this.position + 1] === '/')\r\n    ) {\r\n      if (this.input[this.position] === '\\n') {\r\n        this.line++;\r\n        this.column = 1;\r\n      } else {\r\n        this.column++;\r\n      }\r\n      this.position++;\r\n    }\r\n    this.position += 2; // Skip '*/'\r\n    return {\r\n      type: 'comment',\r\n      value: this.input.slice(start, this.position),\r\n      position: { line: this.line, column: this.column },\r\n    };\r\n  }\r\n\r\n  private consumeDelimiter(): Token {\r\n    const char = this.input[this.position];\r\n    this.position++;\r\n    this.column++;\r\n    return {\r\n      type: 'delimiter',\r\n      value: char,\r\n      position: { line: this.line, column: this.column },\r\n    };\r\n  }\r\n\r\n  private consumeOther(): Token {\r\n    const start = this.position;\r\n    while (\r\n      this.position < this.input.length &&\r\n      !this.isWhitespace(this.input[this.position]) &&\r\n      !this.isCommentStart() &&\r\n      !this.isDelimiter(this.input[this.position])\r\n    ) {\r\n      this.position++;\r\n      this.column++;\r\n    }\r\n    return {\r\n      type: 'other',\r\n      value: this.input.slice(start, this.position),\r\n      position: { line: this.line, column: this.column },\r\n    };\r\n  }\r\n\r\n  public tokenize(): Token[] {\r\n    const tokens: Token[] = [];\r\n\r\n    while (this.position < this.input.length) {\r\n      const char = this.input[this.position];\r\n\r\n      if (this.isWhitespace(char)) {\r\n        this.consumeWhitespace(); // Ignore whitespace tokens\r\n      } else if (this.isCommentStart()) {\r\n        tokens.push(this.consumeComment());\r\n      } else if (this.isDelimiter(char)) {\r\n        tokens.push(this.consumeDelimiter());\r\n      } else {\r\n        tokens.push(this.consumeOther());\r\n      }\r\n    }\r\n\r\n    return tokens;\r\n  }\r\n}\r\n","// Import the Token type from the tokenizer module\r\nimport { Token } from \"../tokenizer\";\r\n\r\nexport type ASTNode = {\r\n  type: string; // e.g., 'stylesheet', 'rule', 'selector', 'declaration', 'value'\r\n  value?: string; // Optional value for the node, e.g., a selector name or property value\r\n  children: ASTNode[]; // Child nodes for nested structures\r\n};\r\n\r\n// Example usage:\r\n// import { Tokenizer } from \"../tokenizer\";\r\n\r\n// const cssInput = `/* Example CSS */\r\n// body {\r\n//   background: white;\r\n//   color: black;\r\n// }`;\r\n// const tokenizer = new Tokenizer(cssInput);\r\n// const tokens = tokenizer.tokenize();\r\n// const astBuilder = new ASTBuilder(tokens);\r\n// console.log(JSON.stringify(astBuilder.buildAST(), null, 2));\r\n\r\nexport class ASTBuilder {\r\n  private tokens: Token[];\r\n  private position: number;\r\n\r\n  constructor(tokens: Token[]) {\r\n    this.tokens = tokens;\r\n    this.position = 0;\r\n  }\r\n\r\n  private currentToken(): Token | null {\r\n    return this.position < this.tokens.length ? this.tokens[this.position] : null;\r\n  }\r\n\r\n  private consumeToken(): Token {\r\n    const token = this.currentToken();\r\n    if (token) this.position++;\r\n    return token!;\r\n  }\r\n\r\n  private parseStylesheet(): ASTNode {\r\n    const stylesheet: ASTNode = { type: 'stylesheet', children: [] };\r\n\r\n    while (this.currentToken()) {\r\n      const rule = this.parseRule();\r\n      if (rule) {\r\n        stylesheet.children.push(rule);\r\n      }\r\n    }\r\n\r\n    return stylesheet;\r\n  }\r\n\r\n  private parseRule(): ASTNode | null {\r\n    const selector = this.parseSelector();\r\n    if (!selector) return null;\r\n\r\n    const rule: ASTNode = { type: 'rule', children: [selector] };\r\n\r\n    const token = this.currentToken();\r\n    if (token?.type === 'other' && token.value === '{') {\r\n      this.consumeToken(); // Consume '{'\r\n      const declarations = this.parseDeclarations();\r\n      rule.children.push(...declarations);\r\n\r\n      const closingBrace = this.currentToken();\r\n      if (closingBrace?.type === 'other' && closingBrace.value === '}') {\r\n        this.consumeToken(); // Consume '}'\r\n      } else {\r\n        throw new Error(`Unexpected token: expected '}' but found ${closingBrace?.value}`);\r\n      }\r\n    }\r\n\r\n    return rule;\r\n  }\r\n\r\n  private parseSelector(): ASTNode | null {\r\n    const token = this.currentToken();\r\n    if (token?.type === 'other') {\r\n      this.consumeToken();\r\n      return { type: 'selector', value: token.value, children: [] };\r\n    }\r\n    return null;\r\n  }\r\n\r\n  private parseDeclarations(): ASTNode[] {\r\n    const declarations: ASTNode[] = [];\r\n\r\n    while (this.currentToken() && this.currentToken()?.value !== '}') {\r\n      const declaration = this.parseDeclaration();\r\n      if (declaration) {\r\n        declarations.push(declaration);\r\n      }\r\n    }\r\n\r\n    return declarations;\r\n  }\r\n\r\n  private parseDeclaration(): ASTNode | null {\r\n    const property = this.parseProperty();\r\n    if (!property) return null;\r\n\r\n    const token = this.currentToken();\r\n    if (token?.type === 'other' && token.value === ':') {\r\n      this.consumeToken(); // Consume ':'\r\n      const value = this.parseValue();\r\n\r\n      if (value) {\r\n        const declaration: ASTNode = { type: 'declaration', children: [property, value] };\r\n\r\n        const semicolon = this.currentToken();\r\n        if (semicolon?.type === 'other' && semicolon.value === ';') {\r\n          this.consumeToken(); // Consume ';'\r\n        }\r\n\r\n        return declaration;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  private parseProperty(): ASTNode | null {\r\n    const token = this.currentToken();\r\n    if (token?.type === 'other') {\r\n      this.consumeToken();\r\n      return { type: 'property', value: token.value, children: [] };\r\n    }\r\n    return null;\r\n  }\r\n\r\n  private parseValue(): ASTNode | null {\r\n    const token = this.currentToken();\r\n    if (token?.type === 'other') {\r\n      this.consumeToken();\r\n      return { type: 'value', value: token.value, children: [] };\r\n    }\r\n    return null;\r\n  }\r\n\r\n  public buildAST(): ASTNode {\r\n    return this.parseStylesheet();\r\n  }\r\n}\r\n","// Example usage:\r\n// import { Tokenizer } from \"../tokenizer\";\r\n// import { ASTBuilder } from \"../ast\";\r\n\r\nimport { ASTNode } from \"../ast/index\";\r\n\r\n// const cssInput = `/* Example CSS */\r\n// body {\r\n//   background: white;\r\n//   color;\r\n// }`;\r\n// const tokenizer = new Tokenizer(cssInput);\r\n// const tokens = tokenizer.tokenize();\r\n// const astBuilder = new ASTBuilder(tokens);\r\n// const ast = astBuilder.buildAST();\r\n\r\n// const validator = new Validator(ast);\r\n// const errors = validator.validate();\r\n// if (errors.length > 0) {\r\n//   console.error(\"Validation errors:\", errors);\r\n// } else {\r\n//   console.log(\"CSS is valid.\");\r\n// }\r\n\r\nexport class CSSValidator {\r\n  private ast: ASTNode;\r\n  private errors: string[];\r\n\r\n  constructor(ast: ASTNode) {\r\n    this.ast = ast;\r\n    this.errors = [];\r\n  }\r\n\r\n  private validateStylesheet(node: ASTNode): void {\r\n    if (node.type !== 'stylesheet') {\r\n      this.errors.push(`Invalid root node type: ${node.type}`);\r\n    }\r\n\r\n    for (const child of node.children) {\r\n      if (child.type === 'rule') {\r\n        this.validateRule(child);\r\n      } else {\r\n        this.errors.push(`Invalid child node type in stylesheet: ${child.type}`);\r\n      }\r\n    }\r\n  }\r\n\r\n  private validateRule(node: ASTNode): void {\r\n    const selector = node.children.find((child) => child.type === 'selector');\r\n    if (!selector || !selector.value) {\r\n      this.errors.push(`Missing or invalid selector in rule.`);\r\n    }\r\n\r\n    const declarations = node.children.filter((child) => child.type === 'declaration');\r\n    for (const declaration of declarations) {\r\n      this.validateDeclaration(declaration);\r\n    }\r\n  }\r\n\r\n  private validateDeclaration(node: ASTNode): void {\r\n    const property = node.children.find((child) => child.type === 'property');\r\n    const value = node.children.find((child) => child.type === 'value');\r\n\r\n    if (!property || !property.value) {\r\n      this.errors.push(`Missing or invalid property in declaration.`);\r\n    }\r\n\r\n    if (!value || !value.value) {\r\n      this.errors.push(`Missing or invalid value in declaration.`);\r\n    }\r\n  }\r\n\r\n  public validate(): string[] {\r\n    this.validateStylesheet(this.ast);\r\n    return this.errors;\r\n  }\r\n}\r\n","import { ASTNode } from \"../ast/index\";\r\n\r\nexport class CSSASTOptimizer {\r\n  private ast: ASTNode;\r\n\r\n  constructor(ast: ASTNode) {\r\n    this.ast = ast;\r\n  }\r\n\r\n  private removeDuplicateDeclarations(node: ASTNode): void {\r\n    if (node.type === 'rule') {\r\n      const declarations = node.children.filter((child) => child.type === 'declaration');\r\n      const uniqueDeclarations: Record<string, ASTNode> = {};\r\n\r\n      for (const declaration of declarations) {\r\n        const propertyNode = declaration.children.find((child) => child.type === 'property');\r\n        if (propertyNode && propertyNode.value) {\r\n          uniqueDeclarations[propertyNode.value] = declaration;\r\n        }\r\n      }\r\n\r\n      node.children = node.children.filter((child) => child.type !== 'declaration').concat(Object.values(uniqueDeclarations));\r\n    }\r\n\r\n    for (const child of node.children) {\r\n      this.removeDuplicateDeclarations(child);\r\n    }\r\n  }\r\n\r\n  private mergeAdjacentRules(node: ASTNode): void {\r\n    if (node.type === 'stylesheet') {\r\n      const ruleMap: Record<string, ASTNode> = {};\r\n\r\n      node.children = node.children.filter((child) => {\r\n        if (child.type === 'rule') {\r\n          const selector = child.children.find((c) => c.type === 'selector');\r\n          if (selector && selector.value) {\r\n            if (ruleMap[selector.value]) {\r\n              ruleMap[selector.value].children.push(\r\n                ...child.children.filter((c) => c.type === 'declaration')\r\n              );\r\n              return false;\r\n            } else {\r\n              ruleMap[selector.value] = child;\r\n            }\r\n          }\r\n        }\r\n        return true;\r\n      });\r\n    }\r\n\r\n    for (const child of node.children) {\r\n      this.mergeAdjacentRules(child);\r\n    }\r\n  }\r\n\r\n  public optimize(): ASTNode {\r\n    this.removeDuplicateDeclarations(this.ast);\r\n    this.mergeAdjacentRules(this.ast);\r\n    return this.ast;\r\n  }\r\n}\r\n","\r\nimport { ASTNode } from \"../ast\";\r\n\r\n  export class CSSCodeGenerator {\r\n    private ast: ASTNode;\r\n  \r\n    constructor(ast: ASTNode) {\r\n      this.ast = ast;\r\n    }\r\n  \r\n    private generateStylesheet(node: ASTNode): string {\r\n      return node.children.map((child) => this.generateRule(child)).join(\"\\n\");\r\n    }\r\n  \r\n    private generateRule(node: ASTNode): string {\r\n      const selector = node.children.find((child) => child.type === 'selector');\r\n      const declarations = node.children.filter((child) => child.type === 'declaration');\r\n  \r\n      if (!selector) {\r\n        throw new Error(\"Rule missing a selector.\");\r\n      }\r\n  \r\n      const selectorText = this.generateSelector(selector);\r\n      const declarationsText = declarations.map((declaration) => this.generateDeclaration(declaration)).join(\"\\n  \");\r\n  \r\n      return `${selectorText} {\r\n    ${declarationsText}\r\n  }`;\r\n    }\r\n  \r\n    private generateSelector(node: ASTNode): string {\r\n      return node.value || \"\";\r\n    }\r\n  \r\n    private generateDeclaration(node: ASTNode): string {\r\n      const property = node.children.find((child) => child.type === 'property');\r\n      const value = node.children.find((child) => child.type === 'value');\r\n  \r\n      if (!property || !value) {\r\n        throw new Error(\"Declaration missing a property or value.\");\r\n      }\r\n  \r\n      return `${property.value}: ${value.value};`;\r\n    }\r\n  \r\n    public generate(): string {\r\n      if (this.ast.type !== 'stylesheet') {\r\n        throw new Error(\"AST root node must be of type 'stylesheet'.\");\r\n      }\r\n  \r\n      return this.generateStylesheet(this.ast);\r\n    }\r\n  }\r\n  ","\r\n// Example usage:\r\n// const cssInput = `/* Example CSS */\r\n// body {\r\n//   background: white;\r\n//   color: black;\r\n//   color: black;\r\n// }`;\r\n\r\nimport { ASTNode, ASTBuilder } from \"../ast/index\";\r\nimport { CSSTokenizer, CSSValidator, CSSASTOptimizer } from \"../index\";\r\n\r\n\r\n\r\n// try {\r\n//   const parser = new Parser(cssInput, true); // Enable validation\r\n//   const ast = parser.parse();\r\n//   console.log(\"Final AST:\", JSON.stringify(ast, null, 2));\r\n// } catch (error) {\r\n//   console.error(error.message);\r\n// }\r\nexport class CSSParser {\r\n  private input: string;\r\n  private validate: boolean;\r\n\r\n  constructor(input: string, validate: boolean = false) {\r\n    this.input = input;\r\n    this.validate = validate;\r\n  }\r\n\r\n  public parse(): ASTNode {\r\n    const tokenizer = new CSSTokenizer(this.input);\r\n    const tokens = tokenizer.tokenize();\r\n\r\n    const astBuilder = new ASTBuilder(tokens);\r\n    let ast = astBuilder.buildAST();\r\n\r\n    if (this.validate) {\r\n      const validator = new CSSValidator(ast);\r\n      const errors = validator.validate();\r\n      if (errors.length > 0) {\r\n        throw new Error(`Validation errors:\\n${errors.join(\"\\n\")}`);\r\n      }\r\n    }\r\n\r\n    const optimizer = new CSSASTOptimizer(ast);\r\n    ast = optimizer.optimize();\r\n\r\n    return ast;\r\n  }\r\n}\r\n"],"names":["CSSTokenizer","constructor","input","this","position","line","column","isWhitespace","char","isCommentStart","isDelimiter","includes","consumeWhitespace","consumeComment","start","length","type","value","slice","consumeDelimiter","consumeOther","tokenize","tokens","push","ASTBuilder","currentToken","consumeToken","token","parseStylesheet","stylesheet","children","rule","parseRule","selector","parseSelector","declarations","parseDeclarations","closingBrace","Error","declaration","parseDeclaration","property","parseProperty","parseValue","semicolon","buildAST","CSSValidator","ast","errors","validateStylesheet","node","child","validateRule","find","filter","validateDeclaration","validate","CSSASTOptimizer","removeDuplicateDeclarations","uniqueDeclarations","propertyNode","concat","Object","values","mergeAdjacentRules","ruleMap","c","optimize","generateStylesheet","map","generateRule","join","generateSelector","generateDeclaration","generate","parse"],"mappings":"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"}