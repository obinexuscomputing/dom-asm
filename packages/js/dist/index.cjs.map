{"version":3,"file":"index.cjs","sources":["../src/tokenizer/index.ts","../src/ast/index.ts","../src/optimizer/index.ts"],"sourcesContent":["export enum TokenType {\r\n  Keyword,\r\n  Identifier,\r\n  Operator,\r\n  Delimiter,\r\n  Literal,\r\n  TemplateLiteral,\r\n  Comment,\r\n  EndOfStatement,\r\n}\r\n\r\nexport interface Token {\r\n  type: TokenType;\r\n  value: string;\r\n}\r\n\r\nexport class Tokenizer {\r\n  private keywords = new Set(['const', 'let', 'var', 'if', 'else', 'function', 'return', 'for', 'while', 'true', 'false']);\r\n  private operators = new Set(['=', '+', '-', '*', '/', '%', '===', '!==', '<', '>', '&&', '||', '!', '==', '=>', '+=', '-=', '*=', '/=', '||=', '&&=', '??', '?.']);\r\n  private delimiters = new Set([';', '{', '}', '(', ')', '[', ']']);\r\n  private singleCharDelimiters = new Set([';', '{', '}', '(', ')', '[', ']']);\r\n  private previousToken: Token | null = null;\r\n\r\n  private isNumericStart(char: string): boolean {\r\n    return /[0-9]/.test(char);\r\n  }\r\n\r\n  private isValidNumber(value: string): boolean {\r\n    const decimalPoints = (value.match(/\\./g) || []).length;\r\n    if (decimalPoints > 1) return false;\r\n\r\n    if (/[eE]/.test(value)) {\r\n      const parts = value.split(/[eE]/);\r\n      if (parts.length !== 2) return false;\r\n      \r\n      const [base, exponent] = parts;\r\n      if (!this.isValidNumber(base)) return false;\r\n      \r\n      const cleanExponent = exponent.replace(/^[+-]/, '');\r\n      if (!/^\\d+$/.test(cleanExponent)) return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  private readNumber(input: string, start: number): [string, number] {\r\n    let current = start;\r\n    let number = '';\r\n    let hasDot = false;\r\n    let hasExponent = false;\r\n\r\n    // Handle leading decimal point\r\n    if (input[current] === '.') {\r\n      if (!/[0-9]/.test(input[current + 1])) {\r\n        throw new Error(`Unexpected character: ${input[current]}`);\r\n      }\r\n      number = '.';\r\n      current++;\r\n    }\r\n\r\n    while (current < input.length) {\r\n      const char = input[current];\r\n      const nextChar = input[current + 1];\r\n\r\n      if (/[0-9]/.test(char)) {\r\n        number += char;\r\n      } else if (char === '.' && !hasDot && !hasExponent) {\r\n        hasDot = true;\r\n        number += char;\r\n      } else if ((char === 'e' || char === 'E') && !hasExponent) {\r\n        hasExponent = true;\r\n        number += char;\r\n        if (nextChar === '+' || nextChar === '-') {\r\n          number += nextChar;\r\n          current++;\r\n        }\r\n      } else if (char === '.' && hasDot) {\r\n        throw new Error('Invalid number format');\r\n      } else {\r\n        break;\r\n      }\r\n      current++;\r\n    }\r\n\r\n    if (!this.isValidNumber(number)) {\r\n      throw new Error('Invalid number format');\r\n    }\r\n\r\n    return [number, current];\r\n  }\r\n\r\n  private readMultilineComment(input: string, start: number): [string, number] {\r\n    let current = start + 2; // Skip /*\r\n    let value = '';\r\n    let depth = 1;\r\n    \r\n    while (current < input.length && depth > 0) {\r\n      if (input[current] === '/' && input[current + 1] === '*') {\r\n        depth++;\r\n        value += '/*';\r\n        current += 2;\r\n      } else if (input[current] === '*' && input[current + 1] === '/') {\r\n        depth--;\r\n        if (depth > 0) {\r\n          value += '*/';\r\n        }\r\n        current += 2;\r\n      } else {\r\n        value += input[current++];\r\n      }\r\n    }\r\n\r\n    if (depth > 0) {\r\n      throw new Error('Unexpected character: EOF');\r\n    }\r\n\r\n    return [value, current];\r\n  }\r\n\r\n  private readTemplateLiteral(input: string, start: number): [string, number] {\r\n    let current = start + 1; // Skip opening backtick\r\n    let value = '';\r\n    \r\n    while (current < input.length && input[current] !== '`') {\r\n      if (input[current] === '\\\\') {\r\n        const nextChar = input[current + 1];\r\n        if (!['`', '$', '\\\\'].includes(nextChar)) {\r\n          throw new Error('Invalid escape sequence');\r\n        }\r\n        value += '\\\\' + nextChar;\r\n        current += 2;\r\n      } else if (input[current] === '$' && input[current + 1] === '{') {\r\n        let braceCount = 1;\r\n        const expressionStart = current;\r\n        current += 2;\r\n        while (current < input.length && braceCount > 0) {\r\n          if (input[current] === '{') braceCount++;\r\n          if (input[current] === '}') braceCount--;\r\n          current++;\r\n        }\r\n        value += input.slice(expressionStart, current);\r\n      } else {\r\n        value += input[current++];\r\n      }\r\n    }\r\n\r\n    if (current >= input.length) {\r\n      throw new Error('Unterminated template literal');\r\n    }\r\n    \r\n    return [value, current + 1]; // Skip closing backtick\r\n  }\r\n\r\n  private readOperator(input: string, start: number): [string, number] {\r\n    let operator = '';\r\n    let maxOperator = '';\r\n    let current = start;\r\n    \r\n    while (current < input.length && /[=!<>&|+\\-*/%?.]/.test(input[current])) {\r\n      operator += input[current];\r\n      if (this.operators.has(operator)) {\r\n        maxOperator = operator;\r\n      }\r\n      current++;\r\n    }\r\n    \r\n    if (operator.includes('=>') && !this.operators.has(operator)) {\r\n      throw new Error('Unexpected character: >');\r\n    }\r\n    \r\n    return [maxOperator, maxOperator.length];\r\n  }\r\n\r\n  private readIdentifier(input: string, start: number): [string, number] {\r\n    let current = start;\r\n    while (current < input.length && /[a-zA-Z0-9_$]/.test(input[current])) {\r\n      current++;\r\n    }\r\n    return [input.slice(start, current), current];\r\n  }\r\n  private shouldAddSemicolon(tokens: Token[]): boolean {\r\n    if (!this.previousToken) {\r\n      return false; // No semicolon needed if there's no previous token\r\n    }\r\n\r\n    return (\r\n      this.previousToken.type !== TokenType.Delimiter &&\r\n      this.previousToken.type !== TokenType.Comment &&\r\n      this.previousToken.type !== TokenType.TemplateLiteral &&\r\n      !tokens.some(token => \r\n        token.type === TokenType.Delimiter && \r\n        token.value === ';' && \r\n        tokens.indexOf(token) === tokens.length - 1\r\n      )\r\n    );\r\n}\r\n  tokenize(input: string): Token[] {\r\n    const tokens: Token[] = [];\r\n    let current = 0;\r\n\r\n    const addToken = (type: TokenType, value: string) => {\r\n      this.previousToken = { type, value };\r\n      tokens.push(this.previousToken);\r\n    };\r\n\r\n    while (current < input.length) {\r\n      let char = input[current];\r\n\r\n      // Handle line continuation with backslashes\r\n      if (char === '\\\\' && input[current + 1] === '\\n') {\r\n        current += 2;\r\n        continue;\r\n      }\r\n\r\n      // Handle whitespace and ASI\r\n      if (/\\s/.test(char)) {\r\n        if (char === '\\n' && this.shouldAddSemicolon(tokens)) {\r\n          addToken(TokenType.Delimiter, ';');\r\n        }\r\n        current++;\r\n        continue;\r\n      }\r\n\r\n      // Handle single-line comments\r\n      if (char === '/' && input[current + 1] === '/') {\r\n        let value = '';\r\n        current += 2;\r\n        \r\n        while (current < input.length && input[current] !== '\\n') {\r\n          value += input[current++];\r\n        }\r\n        \r\n        if (value.endsWith('\\r')) {\r\n          value = value.slice(0, -1);\r\n        }\r\n        \r\n        addToken(TokenType.Comment, value);\r\n        continue;\r\n      }\r\n\r\n      // Handle multi-line comments\r\n      if (char === '/' && input[current + 1] === '*') {\r\n        const [value, newCurrent] = this.readMultilineComment(input, current);\r\n        current = newCurrent;\r\n        addToken(TokenType.Comment, value);\r\n        continue;\r\n      }\r\n\r\n      // Handle template literals\r\n      if (char === '`') {\r\n        const [value, newCurrent] = this.readTemplateLiteral(input, current);\r\n        current = newCurrent;\r\n        addToken(TokenType.TemplateLiteral, value);\r\n        continue;\r\n      }\r\n\r\n      // Handle numbers\r\n      if (this.isNumericStart(char) || (char === '.' && this.isNumericStart(input[current + 1]))) {\r\n        const [number, newCurrent] = this.readNumber(input, current);\r\n        current = newCurrent;\r\n        addToken(TokenType.Literal, number);\r\n        continue;\r\n      }\r\n\r\n      // Handle delimiters\r\n      if (this.singleCharDelimiters.has(char)) {\r\n        addToken(TokenType.Delimiter, char);\r\n        current++;\r\n        continue;\r\n      }\r\n\r\n      // Handle operators\r\n      const [operator, operatorLength] = this.readOperator(input, current);\r\n      if (operator) {\r\n        current += operatorLength;\r\n        addToken(TokenType.Operator, operator);\r\n        continue;\r\n      }\r\n\r\n  // Handle identifiers and keywords\r\nif (/[a-zA-Z_$]/.test(char)) {\r\n  const [value, newCurrent] = this.readIdentifier(input, current);\r\n  current = newCurrent;\r\n  \r\n  // Change this part - treat 'true' and 'false' as identifiers after operators like ||=\r\n  if (this.previousToken && this.previousToken.type === TokenType.Operator) {\r\n    addToken(TokenType.Identifier, value);\r\n  } else if (this.keywords.has(value)) {\r\n    addToken(TokenType.Keyword, value);\r\n  } else {\r\n    addToken(TokenType.Identifier, value);\r\n  }\r\n  continue;\r\n}\r\n      // If we get here, we encountered an unrecognized character\r\n      throw new Error(`Unexpected character: ${char}`);\r\n    }\r\n\r\n    if (this.shouldAddSemicolon(tokens)) {\r\n      addToken(TokenType.Delimiter, ';');\r\n    }\r\n    addToken(TokenType.EndOfStatement, 'EOF');\r\n\r\n    return tokens;\r\n  }\r\n}","import { Token, TokenType } from \"../tokenizer\";\r\n\r\nexport interface ASTNode {\r\n    type: string;          // Node type (e.g., VariableDeclaration, Literal)\r\n    value?: string;        // Value of the node\r\n    children?: ASTNode[];  // Child nodes\r\n  }\r\n  \r\n  export class ASTBuilder {\r\n    build(tokens: Token[]): ASTNode {\r\n      const root: ASTNode = { type: 'Program', children: [] };\r\n      let current = 0;\r\n  \r\n      function walk(): ASTNode {\r\n        const token = tokens[current];\r\n  \r\n        if (token.type === TokenType.Literal) {\r\n          current++;\r\n          return { type: 'Literal', value: token.value };\r\n        }\r\n  \r\n        if (token.type === TokenType.Identifier) {\r\n          current++;\r\n          return { type: 'Identifier', value: token.value };\r\n        }\r\n  \r\n        if (token.type === TokenType.Keyword && token.value === 'const') {\r\n          current++;\r\n          const identifier = walk(); // Identifier\r\n          current++; // Skip '='\r\n          const value = walk(); // Value (expression or literal)\r\n          current++; // Skip ';'\r\n  \r\n          return {\r\n            type: 'VariableDeclaration',\r\n            value: 'const',\r\n            children: [identifier, value],\r\n          };\r\n        }\r\n  \r\nthrow new Error(`Unexpected token: ${token.type === TokenType.EndOfStatement ? 'EOF' : token.value}`);\r\n     }\r\n  \r\n      while (current < tokens.length && tokens[current].type !== TokenType.EndOfStatement) {\r\n        root.children?.push(walk());\r\n      }\r\n  \r\n      return root;\r\n    }\r\n  }\r\n  ","import { ASTNode } from \"../ast\";\r\n\r\nexport class ASTOptimizer {\r\n    optimize(ast: ASTNode): ASTNode {\r\n      // Example: Inline constants\r\n      function simplify(node: ASTNode): ASTNode {\r\n        if (node.type === 'VariableDeclaration' && node.children) {\r\n          const value = node.children[1];\r\n          if (value.type === 'Literal') {\r\n            return { type: 'InlineConstant', value: `${node.children[0].value}=${value.value}` };\r\n          }\r\n        }\r\n  \r\n        if (node.children) {\r\n          node.children = node.children.map(simplify);\r\n        }\r\n  \r\n        return node;\r\n      }\r\n  \r\n      return simplify(ast);\r\n    }\r\n  }\r\n  "],"names":["TokenType","build","tokens","root","type","children","current","walk","token","Literal","value","Identifier","Keyword","identifier","Error","EndOfStatement","length","push","optimize","ast","simplify","node","map","keywords","Set","operators","delimiters","singleCharDelimiters","previousToken","isNumericStart","char","test","isValidNumber","match","parts","split","base","exponent","this","cleanExponent","replace","readNumber","input","start","number","hasDot","hasExponent","nextChar","readMultilineComment","depth","readTemplateLiteral","includes","braceCount","expressionStart","slice","readOperator","operator","maxOperator","has","readIdentifier","shouldAddSemicolon","Delimiter","Comment","TemplateLiteral","some","indexOf","tokenize","addToken","endsWith","newCurrent","operatorLength","Operator"],"mappings":"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"}