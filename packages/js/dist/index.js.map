{"version":3,"file":"index.js","sources":["../src/tokenizer/index.ts","../src/ast/index.ts","../src/optimizer/index.ts"],"sourcesContent":["export enum TokenType {\r\n  Keyword,\r\n  Identifier,\r\n  Operator,\r\n  Delimiter,\r\n  Literal,\r\n  TemplateLiteral,\r\n  Comment,\r\n  EndOfStatement,\r\n}\r\n\r\nexport interface Token {\r\n  type: TokenType;\r\n  value: string;\r\n}\r\n\r\nexport class Tokenizer {\r\n  private keywords = new Set(['const', 'let', 'var', 'if', 'else', 'function', 'return', 'for', 'while', 'true', 'false']);\r\n  private operators = new Set(['=', '+', '-', '*', '/', '%', '===', '!==', '<', '>', '&&', '||', '!', '==', '=>', '+=', '-=', '*=', '/=', '||=', '&&=', '??', '?.']);\r\n  private delimiters = new Set([';', '{', '}', '(', ')', '[', ']']);\r\n  private singleCharDelimiters = new Set([';', '{', '}', '(', ')', '[', ']']);\r\n  private previousToken: Token | null = null;\r\n\r\n  private isNumericStart(char: string): boolean {\r\n    return /[0-9]/.test(char);\r\n  }\r\n\r\n  private isValidNumber(value: string): boolean {\r\n    const decimalPoints = (value.match(/\\./g) || []).length;\r\n    if (decimalPoints > 1) return false;\r\n\r\n    if (/[eE]/.test(value)) {\r\n      const parts = value.split(/[eE]/);\r\n      if (parts.length !== 2) return false;\r\n      \r\n      const [base, exponent] = parts;\r\n      if (!this.isValidNumber(base)) return false;\r\n      \r\n      const cleanExponent = exponent.replace(/^[+-]/, '');\r\n      if (!/^\\d+$/.test(cleanExponent)) return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  private readNumber(input: string, start: number): [string, number] {\r\n    let current = start;\r\n    let number = '';\r\n    let hasDot = false;\r\n    let hasExponent = false;\r\n\r\n    // Handle leading decimal point\r\n    if (input[current] === '.') {\r\n      if (!/[0-9]/.test(input[current + 1])) {\r\n        throw new Error(`Unexpected character: ${input[current]}`);\r\n      }\r\n      number = '.';\r\n      current++;\r\n    }\r\n\r\n    while (current < input.length) {\r\n      const char = input[current];\r\n      const nextChar = input[current + 1];\r\n\r\n      if (/[0-9]/.test(char)) {\r\n        number += char;\r\n      } else if (char === '.' && !hasDot && !hasExponent) {\r\n        hasDot = true;\r\n        number += char;\r\n      } else if ((char === 'e' || char === 'E') && !hasExponent) {\r\n        hasExponent = true;\r\n        number += char;\r\n        if (nextChar === '+' || nextChar === '-') {\r\n          number += nextChar;\r\n          current++;\r\n        }\r\n      } else if (char === '.' && hasDot) {\r\n        throw new Error('Invalid number format');\r\n      } else {\r\n        break;\r\n      }\r\n      current++;\r\n    }\r\n\r\n    if (!this.isValidNumber(number)) {\r\n      throw new Error('Invalid number format');\r\n    }\r\n\r\n    return [number, current];\r\n  }\r\n\r\n  private readMultilineComment(input: string, start: number): [string, number] {\r\n    let current = start + 2; // Skip /*\r\n    let value = '';\r\n    let depth = 1;\r\n    \r\n    while (current < input.length && depth > 0) {\r\n      if (input[current] === '/' && input[current + 1] === '*') {\r\n        depth++;\r\n        value += '/*';\r\n        current += 2;\r\n      } else if (input[current] === '*' && input[current + 1] === '/') {\r\n        depth--;\r\n        if (depth > 0) {\r\n          value += '*/';\r\n        }\r\n        current += 2;\r\n      } else {\r\n        value += input[current++];\r\n      }\r\n    }\r\n\r\n    if (depth > 0) {\r\n      throw new Error('Unexpected character: EOF');\r\n    }\r\n\r\n    return [value, current];\r\n  }\r\n\r\n  private readTemplateLiteral(input: string, start: number): [string, number] {\r\n    let current = start + 1; // Skip opening backtick\r\n    let value = '';\r\n    \r\n    while (current < input.length && input[current] !== '`') {\r\n      if (input[current] === '\\\\') {\r\n        const nextChar = input[current + 1];\r\n        if (!['`', '$', '\\\\'].includes(nextChar)) {\r\n          throw new Error('Invalid escape sequence');\r\n        }\r\n        value += '\\\\' + nextChar;\r\n        current += 2;\r\n      } else if (input[current] === '$' && input[current + 1] === '{') {\r\n        let braceCount = 1;\r\n        const expressionStart = current;\r\n        current += 2;\r\n        while (current < input.length && braceCount > 0) {\r\n          if (input[current] === '{') braceCount++;\r\n          if (input[current] === '}') braceCount--;\r\n          current++;\r\n        }\r\n        value += input.slice(expressionStart, current);\r\n      } else {\r\n        value += input[current++];\r\n      }\r\n    }\r\n\r\n    if (current >= input.length) {\r\n      throw new Error('Unterminated template literal');\r\n    }\r\n    \r\n    return [value, current + 1]; // Skip closing backtick\r\n  }\r\n\r\n  private readOperator(input: string, start: number): [string, number] {\r\n    let operator = '';\r\n    let maxOperator = '';\r\n    let current = start;\r\n    \r\n    while (current < input.length && /[=!<>&|+\\-*/%?.]/.test(input[current])) {\r\n      operator += input[current];\r\n      if (this.operators.has(operator)) {\r\n        maxOperator = operator;\r\n      }\r\n      current++;\r\n    }\r\n    \r\n    if (operator.includes('=>') && !this.operators.has(operator)) {\r\n      throw new Error('Unexpected character: >');\r\n    }\r\n    \r\n    return [maxOperator, maxOperator.length];\r\n  }\r\n\r\n  private readIdentifier(input: string, start: number): [string, number] {\r\n    let current = start;\r\n    while (current < input.length && /[a-zA-Z0-9_$]/.test(input[current])) {\r\n      current++;\r\n    }\r\n    return [input.slice(start, current), current];\r\n  }\r\n  private shouldAddSemicolon(tokens: Token[]): boolean {\r\n    if (!this.previousToken) {\r\n      return false; // No semicolon needed if there's no previous token\r\n    }\r\n\r\n    return (\r\n      this.previousToken.type !== TokenType.Delimiter &&\r\n      this.previousToken.type !== TokenType.Comment &&\r\n      this.previousToken.type !== TokenType.TemplateLiteral &&\r\n      !tokens.some(token => \r\n        token.type === TokenType.Delimiter && \r\n        token.value === ';' && \r\n        tokens.indexOf(token) === tokens.length - 1\r\n      )\r\n    );\r\n}\r\n  tokenize(input: string): Token[] {\r\n    const tokens: Token[] = [];\r\n    let current = 0;\r\n\r\n    const addToken = (type: TokenType, value: string) => {\r\n      this.previousToken = { type, value };\r\n      tokens.push(this.previousToken);\r\n    };\r\n\r\n    while (current < input.length) {\r\n      let char = input[current];\r\n\r\n      // Handle line continuation with backslashes\r\n      if (char === '\\\\' && input[current + 1] === '\\n') {\r\n        current += 2;\r\n        continue;\r\n      }\r\n\r\n      // Handle whitespace and ASI\r\n      if (/\\s/.test(char)) {\r\n        if (char === '\\n' && this.shouldAddSemicolon(tokens)) {\r\n          addToken(TokenType.Delimiter, ';');\r\n        }\r\n        current++;\r\n        continue;\r\n      }\r\n\r\n      // Handle single-line comments\r\n      if (char === '/' && input[current + 1] === '/') {\r\n        let value = '';\r\n        current += 2;\r\n        \r\n        while (current < input.length && input[current] !== '\\n') {\r\n          value += input[current++];\r\n        }\r\n        \r\n        if (value.endsWith('\\r')) {\r\n          value = value.slice(0, -1);\r\n        }\r\n        \r\n        addToken(TokenType.Comment, value);\r\n        continue;\r\n      }\r\n\r\n      // Handle multi-line comments\r\n      if (char === '/' && input[current + 1] === '*') {\r\n        const [value, newCurrent] = this.readMultilineComment(input, current);\r\n        current = newCurrent;\r\n        addToken(TokenType.Comment, value);\r\n        continue;\r\n      }\r\n\r\n      // Handle template literals\r\n      if (char === '`') {\r\n        const [value, newCurrent] = this.readTemplateLiteral(input, current);\r\n        current = newCurrent;\r\n        addToken(TokenType.TemplateLiteral, value);\r\n        continue;\r\n      }\r\n\r\n      // Handle numbers\r\n      if (this.isNumericStart(char) || (char === '.' && this.isNumericStart(input[current + 1]))) {\r\n        const [number, newCurrent] = this.readNumber(input, current);\r\n        current = newCurrent;\r\n        addToken(TokenType.Literal, number);\r\n        continue;\r\n      }\r\n\r\n      // Handle delimiters\r\n      if (this.singleCharDelimiters.has(char)) {\r\n        addToken(TokenType.Delimiter, char);\r\n        current++;\r\n        continue;\r\n      }\r\n\r\n      // Handle operators\r\n      const [operator, operatorLength] = this.readOperator(input, current);\r\n      if (operator) {\r\n        current += operatorLength;\r\n        addToken(TokenType.Operator, operator);\r\n        continue;\r\n      }\r\n\r\n  // Handle identifiers and keywords\r\nif (/[a-zA-Z_$]/.test(char)) {\r\n  const [value, newCurrent] = this.readIdentifier(input, current);\r\n  current = newCurrent;\r\n  \r\n  // Change this part - treat 'true' and 'false' as identifiers after operators like ||=\r\n  if (this.previousToken && this.previousToken.type === TokenType.Operator) {\r\n    addToken(TokenType.Identifier, value);\r\n  } else if (this.keywords.has(value)) {\r\n    addToken(TokenType.Keyword, value);\r\n  } else {\r\n    addToken(TokenType.Identifier, value);\r\n  }\r\n  continue;\r\n}\r\n      // If we get here, we encountered an unrecognized character\r\n      throw new Error(`Unexpected character: ${char}`);\r\n    }\r\n\r\n    if (this.shouldAddSemicolon(tokens)) {\r\n      addToken(TokenType.Delimiter, ';');\r\n    }\r\n    addToken(TokenType.EndOfStatement, 'EOF');\r\n\r\n    return tokens;\r\n  }\r\n}","import { Token, TokenType } from \"../tokenizer\";\r\n\r\nexport interface ASTNode {\r\n    type: string;          // Node type (e.g., VariableDeclaration, Literal)\r\n    value?: string;        // Value of the node\r\n    children?: ASTNode[];  // Child nodes\r\n  }\r\n  \r\n  export class ASTBuilder {\r\n    build(tokens: Token[]): ASTNode {\r\n      const root: ASTNode = { type: 'Program', children: [] };\r\n      let current = 0;\r\n  \r\n      function walk(): ASTNode {\r\n        const token = tokens[current];\r\n  \r\n        if (token.type === TokenType.Literal) {\r\n          current++;\r\n          return { type: 'Literal', value: token.value };\r\n        }\r\n  \r\n        if (token.type === TokenType.Identifier) {\r\n          current++;\r\n          return { type: 'Identifier', value: token.value };\r\n        }\r\n  \r\n        if (token.type === TokenType.Keyword && token.value === 'const') {\r\n          current++;\r\n          const identifier = walk(); // Identifier\r\n          current++; // Skip '='\r\n          const value = walk(); // Value (expression or literal)\r\n          current++; // Skip ';'\r\n  \r\n          return {\r\n            type: 'VariableDeclaration',\r\n            value: 'const',\r\n            children: [identifier, value],\r\n          };\r\n        }\r\n  \r\nthrow new Error(`Unexpected token: ${token.type === TokenType.EndOfStatement ? 'EOF' : token.value}`);\r\n     }\r\n  \r\n      while (current < tokens.length && tokens[current].type !== TokenType.EndOfStatement) {\r\n        root.children?.push(walk());\r\n      }\r\n  \r\n      return root;\r\n    }\r\n  }\r\n  ","import { ASTNode } from \"../ast\";\r\n\r\nexport class ASTOptimizer {\r\n    optimize(ast: ASTNode): ASTNode {\r\n      // Example: Inline constants\r\n      function simplify(node: ASTNode): ASTNode {\r\n        if (node.type === 'VariableDeclaration' && node.children) {\r\n          const value = node.children[1];\r\n          if (value.type === 'Literal') {\r\n            return { type: 'InlineConstant', value: `${node.children[0].value}=${value.value}` };\r\n          }\r\n        }\r\n  \r\n        if (node.children) {\r\n          node.children = node.children.map(simplify);\r\n        }\r\n  \r\n        return node;\r\n      }\r\n  \r\n      return simplify(ast);\r\n    }\r\n  }\r\n  "],"names":["TokenType","Tokenizer","keywords","Set","operators","delimiters","singleCharDelimiters","previousToken","isNumericStart","char","test","isValidNumber","value","match","length","parts","split","base","exponent","this","cleanExponent","replace","readNumber","input","start","current","number","hasDot","hasExponent","Error","nextChar","readMultilineComment","depth","readTemplateLiteral","includes","braceCount","expressionStart","slice","readOperator","operator","maxOperator","has","readIdentifier","shouldAddSemicolon","tokens","type","Delimiter","Comment","TemplateLiteral","some","token","indexOf","tokenize","addToken","push","endsWith","newCurrent","Literal","operatorLength","Operator","Identifier","Keyword","EndOfStatement","ASTBuilder","build","root","children","walk","identifier","ASTOptimizer","optimize","ast","simplify","node","map"],"mappings":"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"}