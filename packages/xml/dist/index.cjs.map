{"version":3,"file":"index.cjs","sources":["../src/ast/DOMXMLAST.ts","../src/ast/DOMXMLASTOptimizer.ts","../src/generator/DOMXMLGenerator.ts","../src/parser/DOMXMLParser.ts","../src/tokenizer/XMLBaseTokenizer.ts","../src/tokenizer/DOMXMLTokenizer.ts","../src/validator/DOMXMLValidator.ts","../src/index.ts"],"sourcesContent":["export interface DOMXMLMetadata {\r\n  nodeCount: number;\r\n  elementCount: number;\r\n  textCount: number;\r\n  commentCount: number;\r\n}\r\n\r\nexport interface DOMXMLASTNode {\r\n  type: \"Element\" | \"Text\" | \"Comment\" | \"Doctype\";\r\n  name?: string;\r\n  value?: string;\r\n  attributes?: Record<string, string>;\r\n  children?: DOMXMLASTNode[];\r\n}\r\n\r\nexport class DOMXMLAST {\r\n  constructor(\r\n    public root: DOMXMLASTNode,\r\n    public metadata: DOMXMLMetadata\r\n  ) {}\r\n\r\n  computeMetadata(): DOMXMLMetadata {\r\n    let nodeCount = 0;\r\n    let elementCount = 0;\r\n    let textCount = 0;\r\n    let commentCount = 0;\r\n\r\n    const traverse = (node: DOMXMLASTNode) => {\r\n      nodeCount++;\r\n      switch (node.type) {\r\n        case \"Element\":\r\n          elementCount++;\r\n          break;\r\n        case \"Text\":\r\n          textCount++;\r\n          break;\r\n        case \"Comment\":\r\n          commentCount++;\r\n          break;\r\n      }\r\n      node.children?.forEach(traverse);\r\n    };\r\n\r\n    traverse(this.root);\r\n\r\n    return {\r\n      nodeCount,\r\n      elementCount,\r\n      textCount,\r\n      commentCount,\r\n    };\r\n  }\r\n  addChildNode(parent: DOMXMLASTNode, child: DOMXMLASTNode): void {\r\n    parent.children = parent.children || [];\r\n    parent.children.push(child);\r\n  }\r\n\r\n  removeChildNode(parent: DOMXMLASTNode, child: DOMXMLASTNode): void {\r\n    parent.children = parent.children?.filter((c) => c !== child) || [];\r\n  }\r\n}\r\n","import { DOMXMLASTNode, DOMXMLAST } from \"./DOMXMLAST\";\r\n\r\nexport class DOMXMLASTOptimizer {\r\n  /**\r\n   * Optimize the given AST by removing redundant nodes, merging text nodes, and recalculating metadata.\r\n   */\r\n  public optimize(ast: DOMXMLAST): DOMXMLAST {\r\n    const optimizedRoot = this.optimizeNode(ast.root);\r\n    const metadata = this.computeMetadata(optimizedRoot); // Use the optimized root\r\n    return new DOMXMLAST(optimizedRoot, metadata);\r\n  }\r\n  \r\n  public optimizeChildren(children: DOMXMLASTNode[]): DOMXMLASTNode[] {\r\n    // First pass: Remove empty text nodes and optimize children recursively\r\n    let optimized = children\r\n      .filter((node) => {\r\n        if (node.type === \"Text\") {\r\n          // Keep non-empty text nodes\r\n          return node.value?.trim() !== \"\";\r\n        }\r\n        if (node.type === \"Element\") {\r\n          // Always keep elements; further optimization happens recursively\r\n          return true;\r\n        }\r\n        return true; // Keep other node types (e.g., Comment, Doctype)\r\n      })\r\n      .map((node) =>\r\n        node.type === \"Element\" && node.children\r\n          ? { ...node, children: this.optimizeChildren(node.children) }\r\n          : node\r\n      );\r\n  \r\n    // Second pass: Merge adjacent text nodes\r\n    let i = 0;\r\n    while (i < optimized.length - 1) {\r\n      const current = optimized[i];\r\n      const next = optimized[i + 1];\r\n      if (current.type === \"Text\" && next.type === \"Text\") {\r\n        current.value = (current.value || \"\") + (next.value || \"\"); // Merge text values\r\n        optimized.splice(i + 1, 1); // Remove the merged node\r\n      } else {\r\n        i++;\r\n      }\r\n    }\r\n  \r\n    return optimized;\r\n  }\r\n  \r\n\r\n  private optimizeNode(node: DOMXMLASTNode): DOMXMLASTNode {\r\n    if (node.children) {\r\n      node.children = this.optimizeChildren(node.children);\r\n    }\r\n    return node;\r\n  }\r\n  \r\n  /**\r\n   * Compute metadata for the optimized AST.\r\n   */\r\n  public computeMetadata(root: DOMXMLASTNode): DOMXMLAST[\"metadata\"] {\r\n    let nodeCount = 0;\r\n    let elementCount = 0;\r\n    let textCount = 0;\r\n    let commentCount = 0;\r\n\r\n    const traverse = (node: DOMXMLASTNode) => {\r\n      nodeCount++;\r\n      switch (node.type) {\r\n        case \"Element\":\r\n          elementCount++;\r\n          break;\r\n        case \"Text\":\r\n          textCount++;\r\n          break;\r\n        case \"Comment\":\r\n          commentCount++;\r\n          break;\r\n      }\r\n      if (node.children) {\r\n        node.children.forEach(traverse);\r\n      }\r\n    };\r\n\r\n    traverse(root);\r\n\r\n    return { nodeCount, elementCount, textCount, commentCount };\r\n  }\r\n}\r\n","import { DOMXMLAST, DOMXMLASTNode } from \"../ast/DOMXMLAST\";\r\n\r\nexport interface GeneratorOptions {\r\n  indent?: string;\r\n  newLine?: string;\r\n  xmlDeclaration?: boolean;\r\n  prettyPrint?: boolean;\r\n}\r\n\r\nexport class DOMXMLGenerator {\r\n  private options: Required<GeneratorOptions>;\r\n\r\n  constructor(options: GeneratorOptions = {}) {\r\n    this.options = {\r\n      indent: options.indent ?? \"  \",\r\n      newLine: options.newLine ?? \"\\n\",\r\n      xmlDeclaration: options.xmlDeclaration ?? true,\r\n      prettyPrint: options.prettyPrint ?? true,\r\n    };\r\n  }\r\n\r\n  public generate(ast: DOMXMLAST): string {\r\n    let result = \"\";\r\n\r\n    if (this.options.xmlDeclaration) {\r\n      result += '<?xml version=\"1.0\" encoding=\"UTF-8\"?>' + this.options.newLine;\r\n    }\r\n\r\n    result += this.generateNode(ast.root, 0);\r\n    return result;\r\n  }\r\n\r\n  private generateNode(node: DOMXMLASTNode, depth: number): string {\r\n    switch (node.type) {\r\n      case \"Element\":\r\n        return this.generateElement(node, depth);\r\n      case \"Text\":\r\n        return this.generateText(node, depth);\r\n      case \"Comment\":\r\n        return this.generateComment(node, depth);\r\n      case \"Doctype\":\r\n        return this.generateDoctype(node, depth);\r\n      default:\r\n        throw new Error(`Unknown node type: ${node.type}`);\r\n    }\r\n  }\r\n\r\n  private generateElement(node: DOMXMLASTNode, depth: number): string {\r\n    const indent = this.options.prettyPrint ? this.getIndent(depth) : \"\";\r\n    let result = indent + \"<\" + (node.name || \"\");\r\n\r\n    if (node.attributes) {\r\n      result += Object.entries(node.attributes)\r\n        .map(\r\n          ([key, value]) => ` ${key}=\"${this.escapeAttribute(String(value))}\"`,\r\n        )\r\n        .join(\"\");\r\n    }\r\n\r\n    if (!node.children?.length) {\r\n      return result + \"/>\" + this.options.newLine;\r\n    }\r\n\r\n    result += \">\";\r\n\r\n    if (node.children.length === 1 && node.children[0].type === \"Text\") {\r\n      result += this.escapeText(node.children[0].value || \"\");\r\n      result += \"</\" + node.name + \">\" + this.options.newLine;\r\n      return result;\r\n    }\r\n\r\n    result += this.options.newLine;\r\n\r\n    for (const child of node.children) {\r\n      result += this.generateNode(child, depth + 1);\r\n    }\r\n\r\n    result += indent + \"</\" + node.name + \">\" + this.options.newLine;\r\n    return result;\r\n  }\r\n\r\n  private generateText(node: DOMXMLASTNode, depth: number): string {\r\n    const indent = this.options.prettyPrint ? this.getIndent(depth) : \"\";\r\n    return indent + this.escapeText(node.value || \"\") + this.options.newLine;\r\n  }\r\n\r\n  private generateComment(node: DOMXMLASTNode, depth: number): string {\r\n    const indent = this.options.prettyPrint ? this.getIndent(depth) : \"\";\r\n    return indent + \"<!--\" + (node.value || \"\") + \"-->\" + this.options.newLine;\r\n  }\r\n\r\n  private generateDoctype(node: DOMXMLASTNode, depth: number): string {\r\n    const indent = this.options.prettyPrint ? this.getIndent(depth) : \"\";\r\n    return (\r\n      indent + \"<!DOCTYPE \" + (node.value || \"\") + \">\" + this.options.newLine\r\n    );\r\n  }\r\n\r\n  private getIndent(depth: number): string {\r\n    return this.options.indent.repeat(depth);\r\n  }\r\n\r\n  private escapeText(text: string): string {\r\n    return text\r\n      .replace(/&/g, \"&amp;\")\r\n      .replace(/</g, \"&lt;\")\r\n      .replace(/>/g, \"&gt;\");\r\n  }\r\n\r\n  private escapeAttribute(text: string): string {\r\n    return text\r\n      .replace(/&/g, \"&amp;\")\r\n      .replace(/</g, \"&lt;\")\r\n      .replace(/>/g, \"&gt;\")\r\n      .replace(/\"/g, \"&quot;\")\r\n      .replace(/'/g, \"&apos;\");\r\n  }\r\n}\r\n","import { DOMXMLAST, DOMXMLASTNode } from \"../ast/DOMXMLAST\";\r\nimport { DOMXMLToken } from \"../tokenizer/DOMXMLTokenizer\";\r\n\r\nexport class DOMXMLParser {\r\n  private tokens: DOMXMLToken[];\r\n  private position: number;\r\n\r\n  constructor(tokens?: DOMXMLToken[]) {\r\n    this.tokens = tokens || [];\r\n    this.position = 0;\r\n  }\r\n\r\n  /**\r\n   * Set new tokens for parsing.\r\n   * @param tokens - Array of DOMXMLToken objects.\r\n   */\r\n  public setTokens(tokens: DOMXMLToken[]): void {\r\n    this.tokens = tokens;\r\n    this.position = 0;\r\n  }\r\n\r\n  /**\r\n   * Parses the tokens into a DOMXMLAST.\r\n   * @returns The parsed DOMXMLAST.\r\n   */\r\n  public parse(): DOMXMLAST {\r\n    this.position = 0;\r\n  \r\n    const virtualRoot: DOMXMLASTNode = {\r\n      type: \"Element\",\r\n      name: \"#document\",\r\n      children: [],\r\n      attributes: {},\r\n    };\r\n  \r\n    const stack: DOMXMLASTNode[] = [virtualRoot];\r\n    let currentNode = virtualRoot;\r\n  \r\n    while (this.position < this.tokens.length) {\r\n      const token = this.tokens[this.position++];\r\n  \r\n      switch (token.type) {\r\n        case \"StartTag\": {\r\n          const elementNode: DOMXMLASTNode = {\r\n            type: \"Element\",\r\n            name: token.name!,\r\n            attributes: token.attributes || {},\r\n            children: [],\r\n          };\r\n          currentNode.children!.push(elementNode);\r\n          if (!token.selfClosing) {\r\n            stack.push(elementNode);\r\n            currentNode = elementNode;\r\n          }\r\n          break;\r\n        }\r\n  \r\n        case \"EndTag\": {\r\n          if (stack.length > 1) {\r\n            const openTag = stack.pop()!;\r\n            if (openTag.name !== token.name) {\r\n              throw new Error(\r\n                `Mismatched tags: expected closing tag for \"${openTag.name}\", but found \"${token.name}\".`\r\n              );\r\n            }\r\n            currentNode = stack[stack.length - 1];\r\n          } else {\r\n            throw new Error(`Unexpected closing tag: \"${token.name}\".`);\r\n          }\r\n          break;\r\n        }\r\n  \r\n        case \"Text\": {\r\n          const textValue = token.value?.trim();\r\n          if (textValue) {\r\n            currentNode.children!.push({\r\n              type: \"Text\",\r\n              value: textValue,\r\n            });\r\n          }\r\n          break;\r\n        }\r\n  \r\n        case \"Comment\": {\r\n          currentNode.children!.push({\r\n            type: \"Comment\",\r\n            value: token.value || \"\",\r\n          });\r\n          break;\r\n        }\r\n  \r\n        case \"Doctype\": {\r\n          currentNode.children!.push({\r\n            type: \"Doctype\",\r\n            value: token.value || \"\",\r\n          });\r\n          break;\r\n        }\r\n  \r\n        default:\r\n          throw new Error(`Unexpected token type: \"${token.type}\".`);\r\n      }\r\n    }\r\n  \r\n    if (stack.length > 1) {\r\n      const unclosedTag = stack.pop()!;\r\n      throw new Error(`Unclosed tag: \"${unclosedTag.name}\".`);\r\n    }\r\n  \r\n    const root = virtualRoot.children![0];\r\n    const metadata = this.computeMetadata(root);\r\n  \r\n    return new DOMXMLAST(root, metadata);\r\n  }\r\n\r\n  /**\r\n   * Computes metadata for the AST.\r\n   * @param root - The root node of the AST.\r\n   * @returns Metadata containing node counts.\r\n   */\r\n  private computeMetadata(root: DOMXMLASTNode): DOMXMLAST[\"metadata\"] {\r\n    let nodeCount = 0;\r\n    let elementCount = 0;\r\n    let textCount = 0;\r\n    let commentCount = 0;\r\n\r\n    const traverse = (node: DOMXMLASTNode) => {\r\n      nodeCount++;\r\n      switch (node.type) {\r\n        case \"Element\":\r\n          elementCount++;\r\n          node.children?.forEach(traverse);\r\n          break;\r\n        case \"Text\":\r\n          textCount++;\r\n          break;\r\n        case \"Comment\":\r\n          commentCount++;\r\n          break;\r\n      }\r\n    };\r\n\r\n    traverse(root);\r\n\r\n    return {\r\n      nodeCount,\r\n      elementCount,\r\n      textCount,\r\n      commentCount,\r\n    };\r\n  }\r\n}\r\n","export abstract class XMLBaseTokenizer {\r\n  protected input: string;\r\n  protected position: number;\r\n  protected line: number;\r\n  protected column: number;\r\n  protected type: string | undefined;\r\n\r\n  constructor(input: string) {\r\n    this.input = input;\r\n    this.position = 0;\r\n    this.line = 1;\r\n    this.column = 1;\r\n  }\r\n\r\n  public abstract tokenize(): unknown[];\r\n\r\n  protected peek(offset: number = 0): string {\r\n    return this.input[this.position + offset] || '';\r\n  }\r\n\r\n  protected peekSequence(length: number): string {\r\n    return this.input.slice(this.position, this.position + length);\r\n  }\r\n\r\n  protected matches(str: string): boolean {\r\n    return this.input.startsWith(str, this.position);\r\n  }\r\n  protected consume(): string {\r\n    const char = this.peek();\r\n    if (char === '\\n') {\r\n      this.line++;\r\n      this.column = 1; // Reset column on a new line\r\n    } else {\r\n      this.column++;\r\n    }\r\n    this.position++;\r\n    return char;\r\n  }\r\n  \r\n  \r\n  protected consumeSequence(length: number): string {\r\n    let result = '';\r\n    for (let i = 0; i < length; i++) {\r\n      result += this.consume();\r\n    }\r\n    return result;\r\n  }\r\n  \r\n  protected readUntil(\r\n    stop: string | RegExp,\r\n    options: { escape?: boolean; includeStop?: boolean; skipStop?: boolean } = {}\r\n  ): string {\r\n    const { escape = false, includeStop = false, skipStop = true } = options;\r\n    let result = '';\r\n    let escaped = false;\r\n  \r\n    while (this.position < this.input.length) {\r\n      const current = this.peek();\r\n  \r\n      // Handle escape sequences if `escape` is enabled\r\n      if (escape && current === '\\\\' && !escaped) {\r\n        escaped = true;\r\n        result += this.consume();\r\n        continue;\r\n      }\r\n  \r\n      const matches =\r\n        typeof stop === 'string' ? this.matches(stop) : stop.test(current);\r\n  \r\n      // Check for the stop condition\r\n      if (!escaped && matches) {\r\n        if (includeStop) {\r\n          if (typeof stop === 'string') {\r\n            result += this.consumeSequence(stop.length); // Consume the stop string\r\n          } else {\r\n            result += this.consume(); // Consume the matching character\r\n          }\r\n        } else if (skipStop) {\r\n          this.position += typeof stop === 'string' ? stop.length : 1; // Skip the stop character(s)\r\n        }\r\n        break; // Exit the loop once the stop condition is met\r\n      }\r\n  \r\n      // Append the current character to the result\r\n      result += this.consume();\r\n      escaped = false; // Reset escape flag after consuming a character\r\n    }\r\n  \r\n    return result;\r\n  }\r\n  \r\n\r\n  protected readWhile(predicate: (char: string, index: number) => boolean): string {\r\n    let result = '';\r\n    let index = 0;\r\n    \r\n    while (this.position < this.input.length && predicate(this.peek(), index)) {\r\n      result += this.consume();\r\n      index++;\r\n    }\r\n    \r\n    return result;\r\n  }\r\n\r\n  protected skipWhitespace(): void {\r\n    this.readWhile(char => /\\s/.test(char));\r\n  }\r\n\r\n  protected getCurrentLocation(): { line: number; column: number } {\r\n    return { line: this.line, column: this.column };\r\n  }\r\n\r\n  protected isNameChar(char: string): boolean {\r\n    return /[a-zA-Z0-9_\\-:]/.test(char);\r\n  }\r\n\r\n  protected isIdentifierStart(char: string): boolean {\r\n    return /[a-zA-Z_]/.test(char);\r\n  }\r\n\r\n  protected isIdentifierPart(char: string): boolean {\r\n    return /[a-zA-Z0-9_\\-]/.test(char);\r\n  }\r\n\r\n  protected readIdentifier(): string {\r\n    if (!this.isIdentifierStart(this.peek())) {\r\n      return '';\r\n    }\r\n    return this.readWhile((char, index) => \r\n      index === 0 ? this.isIdentifierStart(char) : this.isIdentifierPart(char)\r\n    );\r\n  }\r\n\r\n  protected readQuotedString(): string {\r\n    const quote = this.peek();\r\n    if (quote !== '\"' && quote !== \"'\") {\r\n      return '';\r\n    }\r\n\r\n    this.consume(); // Skip opening quote\r\n    const value = this.readUntil(quote, { escape: true });\r\n    this.consume(); // Skip closing quote\r\n    return value;\r\n  }\r\n\r\n  protected hasMore(): boolean {\r\n    return this.position < this.input.length;\r\n  }\r\n\r\n  protected addError(message: string): void {\r\n    const location = this.getCurrentLocation();\r\n    console.error(`Error at line ${location.line}, column ${location.column}: ${message}`);\r\n  }\r\n\r\n  protected saveState(): { position: number; line: number; column: number } {\r\n    return {\r\n      position: this.position,\r\n      line: this.line,\r\n      column: this.column\r\n    };\r\n  }\r\n\r\n  protected restoreState(state: { position: number; line: number; column: number }): void {\r\n    this.position = state.position;\r\n    this.line = state.line;\r\n    this.column = state.column;\r\n  }\r\n}","import { XMLBaseTokenizer } from './XMLBaseTokenizer';\r\n\r\nexport interface DOMXMLToken {\r\n  type: 'StartTag' | 'EndTag' | 'Text' | 'Comment' | 'Doctype';\r\n  name?: string;\r\n  value?: string;\r\n  attributes?: Record<string, string>;\r\n  selfClosing?: boolean;\r\n  location: { line: number; column: number };\r\n}\r\n\r\nexport class DOMXMLTokenizer extends XMLBaseTokenizer {\r\n  constructor(input: string) {\r\n    super(input);\r\n  }\r\n  \r\n\r\n  public tokenize(): DOMXMLToken[] {\r\n    const tokens: DOMXMLToken[] = [];\r\n    let textStart: { line: number; column: number } | null = null;\r\n    let textContent = '';\r\n\r\n    while (this.position < this.input.length) {\r\n      const char = this.peek();\r\n      const currentPosition = { line: this.line, column: this.column };\r\n\r\n      if (char === '<') {\r\n        // Flush accumulated text content\r\n        if (textContent.trim()) {\r\n          tokens.push({\r\n            type: 'Text',\r\n            value: textContent.trim(),\r\n            location: textStart!,\r\n          });\r\n        }\r\n        textContent = '';\r\n        textStart = null;\r\n\r\n        // Process tags\r\n        if (this.matches('<!--')) {\r\n          tokens.push(this.readComment(currentPosition));\r\n        } else if (this.matches('<!DOCTYPE')) {\r\n          tokens.push(this.readDoctype(currentPosition));\r\n        } else if (this.peek(1) === '/') {\r\n          tokens.push(this.readEndTag(currentPosition));\r\n        } else {\r\n          tokens.push(this.readStartTag(currentPosition));\r\n        }\r\n      } else {\r\n        // Accumulate text content\r\n        if (!textStart) {\r\n          textStart = { ...currentPosition };\r\n        }\r\n        textContent += this.consume();\r\n      }\r\n    }\r\n\r\n    // Add remaining text content\r\n    if (textContent.trim()) {\r\n      tokens.push({\r\n        type: 'Text',\r\n        value: textContent.trim(),\r\n        location: textStart!,\r\n      });\r\n    }\r\n\r\n    return tokens;\r\n  }\r\n  public readText(): DOMXMLToken {\r\n    const startLocation = this.getCurrentLocation();\r\n    const value = this.readUntil('<', { includeStop: false }); // Stop before the next tag\r\n  \r\n    return {\r\n      type: 'Text',\r\n      value: value.trim(),\r\n      location: startLocation, // Correct start position of the text\r\n    };\r\n  }\r\n  \r\n  private readStartTag(startLocation: { line: number; column: number }): DOMXMLToken {\r\n    this.consume(); // Skip '<'\r\n    const name = this.readTagName();\r\n    const attributes = this.readAttributes();\r\n    let selfClosing = false;\r\n  \r\n    this.skipWhitespace();\r\n    if (this.peek() === '/') {\r\n      selfClosing = true;\r\n      this.consume(); // Skip '/'\r\n    }\r\n    if (this.peek() === '>') {\r\n      this.consume(); // Skip '>'\r\n    }\r\n  \r\n    return {\r\n      type: 'StartTag',\r\n      name,\r\n      attributes,\r\n      selfClosing,\r\n      location: startLocation, // Correctly tracks initial position\r\n    };\r\n  }\r\n  \r\n  \r\n  private readEndTag(startLocation: { line: number; column: number }): DOMXMLToken {\r\n    this.consumeSequence(2); // Skip '</'\r\n    const name = this.readTagName();\r\n    this.skipWhitespace();\r\n    if (this.peek() === '>') {\r\n      this.consume();\r\n    }\r\n\r\n    return {\r\n      type: 'EndTag',\r\n      name,\r\n      location: startLocation,\r\n    };\r\n  }\r\n\r\n  private readComment(startLocation: { line: number; column: number }): DOMXMLToken {\r\n    this.consumeSequence(4); // Skip '<!--'\r\n    const value = this.readUntil('-->');\r\n    this.consumeSequence(3); // Skip '-->'\r\n    return {\r\n      type: 'Comment',\r\n      value: value.trim(),\r\n      location: startLocation,\r\n    };\r\n  }\r\n\r\n  private readDoctype(startLocation: { line: number; column: number }): DOMXMLToken {\r\n    this.consumeSequence(9); // Skip '<!DOCTYPE'\r\n    this.skipWhitespace();\r\n    const value = this.readUntil('>');\r\n    this.consume(); // Skip '>'\r\n    return {\r\n      type: 'Doctype',\r\n      value: value.trim(),\r\n      location: startLocation,\r\n    };\r\n  }\r\n\r\n  private readAttributes(): Record<string, string> {\r\n    const attributes: Record<string, string> = {};\r\n\r\n    while (this.position < this.input.length) {\r\n      this.skipWhitespace();\r\n      if (this.peek() === '>' || this.peek() === '/' || !this.peek()) {\r\n        break;\r\n      }\r\n\r\n      const name = this.readAttributeName();\r\n      if (!name) break;\r\n\r\n      this.skipWhitespace();\r\n      if (this.peek() === '=') {\r\n        this.consume(); // Skip '='\r\n        this.skipWhitespace();\r\n        attributes[name] = this.readAttributeValue();\r\n      } else {\r\n        attributes[name] = 'true'; // Boolean attribute\r\n      }\r\n    }\r\n\r\n    return attributes;\r\n  }\r\n  \r\n  private readTagName(): string {\r\n    return this.readWhile((char) => this.isNameChar(char));\r\n  }\r\n\r\n  private readAttributeName(): string {\r\n    return this.readWhile((char) => this.isNameChar(char));\r\n  }\r\n\r\n  private readAttributeValue(): string {\r\n    const quote = this.peek();\r\n    if (quote === '\"' || quote === \"'\") {\r\n      this.consume(); // Skip opening quote\r\n      const value = this.readUntil(quote);\r\n      this.consume(); // Skip closing quote\r\n      return value;\r\n    }\r\n    return this.readUntil(/[\\s>\\/]/);\r\n  }\r\n}\r\n","import { DOMXMLAST, DOMXMLASTNode } from \"../ast/DOMXMLAST\";\r\n\r\nexport interface ValidationOptions {\r\n  strictMode?: boolean;\r\n  allowUnknownElements?: boolean;\r\n  schema?: XMLSchema;\r\n  customValidators?: Array<(ast: DOMXMLAST) => ValidationError[]>;\r\n}\r\n\r\nexport interface ValidationResult {\r\n  valid: boolean;\r\n  errors: ValidationError[];\r\n}\r\n\r\nexport interface ValidationError {\r\n  code: string;\r\n  message: string;\r\n  line?: number;\r\n  column?: number;\r\n  nodePath?: string;\r\n}\r\n\r\nexport interface XMLSchema {\r\n  elements: Record<string, XMLElementSchema>;\r\n}\r\n\r\nexport interface XMLElementSchema {\r\n  attributes?: string[];\r\n  required?: string[];\r\n  children?: string[];\r\n  minOccurs?: number;\r\n  maxOccurs?: number;\r\n}\r\n\r\nexport class DOMXMLValidator {\r\n  private options: Required<ValidationOptions>;\r\n  private schema?: XMLSchema;\r\n\r\n  constructor(options: ValidationOptions = {}) {\r\n    this.options = {\r\n      strictMode: false,\r\n      allowUnknownElements: true,\r\n      schema: options.schema,\r\n      customValidators: options.customValidators || [],\r\n    } as Required<ValidationOptions>;\r\n\r\n    this.schema = options.schema;\r\n  }\r\n\r\n  public validate(ast: DOMXMLAST): ValidationResult {\r\n    const errors: ValidationError[] = [];\r\n\r\n    if (this.schema) {\r\n      this.validateNode(ast.root, errors, []);\r\n    }\r\n\r\n    this.options.customValidators.forEach((validator) => {\r\n      errors.push(...validator(ast));\r\n    });\r\n\r\n    return {\r\n      valid: errors.length === 0,\r\n      errors,\r\n    };\r\n  }\r\n\r\n  private validateNode(\r\n    node: DOMXMLASTNode,\r\n    errors: ValidationError[],\r\n    path: string[],\r\n  ): void {\r\n    if (node.type !== \"Element\") return;\r\n\r\n    const currentPath = [...path, node.name || \"\"];\r\n\r\n    if (this.schema?.elements) {\r\n      const elementSchema = this.schema.elements[node.name || \"\"];\r\n\r\n      if (!elementSchema && this.options.strictMode) {\r\n        errors.push({\r\n          code: \"UNKNOWN_ELEMENT\",\r\n          message: `Unknown element: ${node.name}`,\r\n          nodePath: currentPath.join(\"/\"),\r\n        });\r\n        return;\r\n      }\r\n\r\n      if (elementSchema) {\r\n        this.validateAttributes(node, elementSchema, errors, currentPath);\r\n        this.validateChildren(node, elementSchema, errors, currentPath);\r\n      }\r\n    }\r\n\r\n    node.children?.forEach((child:DOMXMLASTNode) => {\r\n      this.validateNode(child, errors, currentPath);\r\n    });\r\n  }\r\n\r\n  private validateAttributes(\r\n    node: DOMXMLASTNode,\r\n    schema: XMLElementSchema,\r\n    errors: ValidationError[],\r\n    path: string[],\r\n  ): void {\r\n    const attributes = node.attributes || {};\r\n\r\n    // Check required attributes\r\n    schema.required?.forEach((required) => {\r\n      if (!attributes[required]) {\r\n        errors.push({\r\n          code: \"MISSING_REQUIRED_ATTRIBUTE\",\r\n          message: `Missing required attribute: ${required}`,\r\n          nodePath: path.join(\"/\"),\r\n        });\r\n      }\r\n    });\r\n\r\n    // Check unknown attributes in strict mode\r\n    if (this.options.strictMode && schema.attributes) {\r\n      Object.keys(attributes).forEach((attr) => {\r\n        if (!schema.attributes?.includes(attr)) {\r\n          errors.push({\r\n            code: \"UNKNOWN_ATTRIBUTE\",\r\n            message: `Unknown attribute: ${attr}`,\r\n            nodePath: path.join(\"/\"),\r\n          });\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  private validateChildren(\r\n    node: DOMXMLASTNode,\r\n    schema: XMLElementSchema,\r\n    errors: ValidationError[],\r\n    path: string[],\r\n  ): void {\r\n    const children = node.children || [];\r\n    const elementChildren = children.filter(\r\n      (child:DOMXMLASTNode) => child.type === \"Element\",\r\n    );\r\n\r\n    if (schema.children) {\r\n      elementChildren.forEach((child:DOMXMLASTNode) => {\r\n        if (\r\n          child.type === \"Element\" &&\r\n          !schema.children?.includes(child.name || \"\")\r\n        ) {\r\n          errors.push({\r\n            code: \"INVALID_CHILD_ELEMENT\",\r\n            message: `Invalid child element: ${child.name}`,\r\n            nodePath: path.join(\"/\"),\r\n          });\r\n        }\r\n      });\r\n    }\r\n  }\r\n}\r\n","import { DOMXMLAST } from \"./ast/DOMXMLAST\";\r\nimport { DOMXMLASTOptimizer } from \"./ast/DOMXMLASTOptimizer\";\r\nimport { GeneratorOptions, DOMXMLGenerator } from \"./generator/DOMXMLGenerator\";\r\nimport { DOMXMLParser } from \"./parser/DOMXMLParser\";\r\nimport { DOMXMLTokenizer } from \"./tokenizer/DOMXMLTokenizer\";\r\nimport { ValidationOptions, DOMXMLValidator, ValidationResult } from \"./validator/DOMXMLValidator\";\r\n\r\n// Export AST types and components\r\nexport type { DOMXMLAST, DOMXMLASTNode } from \"./ast/DOMXMLAST\";\r\nexport { DOMXMLASTOptimizer } from \"./ast/DOMXMLASTOptimizer\";\r\n\r\n// Export tokenizer components\r\nexport { XMLBaseTokenizer } from \"./tokenizer/XMLBaseTokenizer\";\r\nexport { DOMXMLTokenizer } from \"./tokenizer/DOMXMLTokenizer\";\r\nexport type { DOMXMLToken } from \"./tokenizer/DOMXMLTokenizer\";\r\n\r\n// Export parser\r\nexport { DOMXMLParser } from \"./parser/DOMXMLParser\";\r\n\r\n// Export generator\r\nexport { DOMXMLGenerator } from \"./generator/DOMXMLGenerator\";\r\nexport type { GeneratorOptions } from \"./generator/DOMXMLGenerator\";\r\n\r\n// Export validator\r\nexport {\r\n  DOMXMLValidator,\r\n  type ValidationOptions,\r\n  type ValidationResult,\r\n  type ValidationError,\r\n  type XMLSchema,\r\n  type XMLElementSchema,\r\n} from \"./validator/DOMXMLValidator\";\r\n\r\n// Export main interface\r\nexport interface DOMXMLOptions {\r\n  validateOnParse?: boolean;\r\n  optimizeAST?: boolean;\r\n  generatorOptions?: GeneratorOptions;\r\n  validationOptions?: ValidationOptions;\r\n}\r\n\r\nexport class DOMXML {\r\n  private tokenizer: DOMXMLTokenizer;\r\n  private parser: DOMXMLParser;\r\n  private optimizer: DOMXMLASTOptimizer;\r\n  private generator: DOMXMLGenerator;\r\n  private validator: DOMXMLValidator;\r\n  private options: DOMXMLOptions;\r\n\r\n  constructor(options: DOMXMLOptions = {}) {\r\n    this.options = {\r\n      validateOnParse: false,\r\n      optimizeAST: true,\r\n      ...options,\r\n    };\r\n\r\n    this.tokenizer = new DOMXMLTokenizer(\"\");\r\n    this.parser = new DOMXMLParser();\r\n    this.optimizer = new DOMXMLASTOptimizer();\r\n    this.generator = new DOMXMLGenerator(options.generatorOptions);\r\n    this.validator = new DOMXMLValidator(options.validationOptions);\r\n  }\r\n\r\n  public parse(input: string): DOMXMLAST {\r\n    this.tokenizer = new DOMXMLTokenizer(input);\r\n    const tokens = this.tokenizer.tokenize();\r\n    \r\n    // Update parser with new tokens\r\n    this.parser.setTokens(tokens);\r\n    let ast = this.parser.parse();\r\n\r\n    if (this.options.validateOnParse) {\r\n      const validationResult = this.validator.validate(ast);\r\n      if (!validationResult.valid) {\r\n        throw new Error(\r\n          `XML Validation failed: ${JSON.stringify(validationResult.errors)}`\r\n        );\r\n      }\r\n    }\r\n\r\n    if (this.options.optimizeAST) {\r\n      ast = this.optimizer.optimize(ast);\r\n    }\r\n\r\n    return ast;\r\n  }\r\n\r\n  // Rest of the implementation remains the same\r\n  public generate(ast: DOMXMLAST): string {\r\n    return this.generator.generate(ast);\r\n  }\r\n\r\n  public validate(ast: DOMXMLAST): ValidationResult {\r\n    return this.validator.validate(ast);\r\n  }\r\n\r\n  public optimize(ast: DOMXMLAST): DOMXMLAST {\r\n    return this.optimizer.optimize(ast);\r\n  }\r\n}"],"names":["DOMXMLAST","constructor","root","metadata","this","computeMetadata","nodeCount","elementCount","textCount","commentCount","traverse","node","type","children","forEach","addChildNode","parent","child","push","removeChildNode","filter","c","DOMXMLASTOptimizer","optimize","ast","optimizedRoot","optimizeNode","optimizeChildren","optimized","value","trim","map","i","length","current","next","splice","DOMXMLGenerator","options","indent","newLine","xmlDeclaration","prettyPrint","generate","result","generateNode","depth","generateElement","generateText","generateComment","generateDoctype","Error","getIndent","name","attributes","Object","entries","key","escapeAttribute","String","join","escapeText","repeat","text","replace","DOMXMLParser","tokens","position","setTokens","parse","virtualRoot","stack","currentNode","token","elementNode","selfClosing","openTag","pop","textValue","unclosedTag","XMLBaseTokenizer","input","line","column","peek","offset","peekSequence","slice","matches","str","startsWith","consume","char","consumeSequence","readUntil","stop","escape","includeStop","skipStop","escaped","test","readWhile","predicate","index","skipWhitespace","getCurrentLocation","isNameChar","isIdentifierStart","isIdentifierPart","readIdentifier","readQuotedString","quote","hasMore","addError","message","location","console","error","saveState","restoreState","state","DOMXMLTokenizer","super","tokenize","textStart","textContent","currentPosition","readComment","readDoctype","readEndTag","readStartTag","readText","startLocation","readTagName","readAttributes","readAttributeName","readAttributeValue","DOMXMLValidator","strictMode","allowUnknownElements","schema","customValidators","validate","errors","validateNode","validator","valid","path","currentPath","elements","elementSchema","code","nodePath","validateAttributes","validateChildren","required","keys","attr","includes","elementChildren","validateOnParse","optimizeAST","tokenizer","parser","optimizer","generator","generatorOptions","validationOptions","validationResult","JSON","stringify"],"mappings":"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"}