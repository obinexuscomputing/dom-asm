!function(t,i){"object"==typeof exports&&"undefined"!=typeof module?i(exports):"function"==typeof define&&define.amd?define(["exports"],i):i((t="undefined"!=typeof globalThis?globalThis:t||self).DOMAST={})}(this,(function(t){"use strict";t.StateMachine=class{constructor(t,i){this.currentState=t,this.transitions=i,this.states=new Set(i.flatMap((t=>[t.from,t.to]))),this.alphabet=new Set(i.map((t=>t.on)))}getCurrentState(){return this.currentState}transition(t){const i=this.transitions.find((i=>i.from===this.currentState&&i.on===t));if(!i)throw new Error(`Invalid transition from ${this.currentState} on ${t}`);this.currentState=i.to}minimize(){const t=new Set,i=new Set([...this.states].filter((t=>!this.isFinalState(t)))),n=new Set([...this.states].filter((t=>this.isFinalState(t))));t.add(i),t.add(n);let e=!0;for(;e;){e=!1;for(const i of t){const[n,...s]=[...i],r=new Set,o=new Set([n]);for(const i of s)this.areEquivalent(n,i,t)?o.add(i):(r.add(new Set([i])),e=!0);if(r.size>0){t.delete(i),t.add(o);for(const i of r)t.add(i)}}}this.updateTransitions(t)}isFinalState(t){return!1}areEquivalent(t,i,n){for(const e of this.alphabet){const s=this.getNextState(t,e),r=this.getNextState(i,e);if(s!==r&&!this.inSamePartition(s,r,n))return!1}return!0}getNextState(t,i){const n=this.transitions.find((n=>n.from===t&&n.on===i));return n?n.to:null}inSamePartition(t,i,n){if(t===i)return!0;for(const e of n)if(e.has(t)&&e.has(i))return!0;return!1}updateTransitions(t){const i=new Map;for(const n of t){const[t]=[...n];for(const e of n)i.set(e,t)}this.transitions=this.transitions.map((t=>({from:i.get(t.from),to:i.get(t.to),on:t.on}))),this.states=new Set(i.values()),this.currentState=i.get(this.currentState)}},t.StateMachineAST=class{constructor(t,i){this.root=t,this.automaton=i}optimizeAST(){const t=new Map,i=n=>{if(t.has(n.id))return t.get(n.id);const e={...n,transitions:{}};return Object.entries(n.transitions).forEach((([t,s])=>{const r=this.automaton.transitions[n.id]?.[t];r&&(e.transitions[t]=i({...n,id:r}).id)})),t.set(n.id,e),e};return i(this.root)}},t.StateMachineASTOptimizer=class{static optimizeAST(t,i){const n=new Map;return function t(e){if(n.has(e.id))return n.get(e.id);const s={...e,transitions:{}};return Object.entries(e.transitions).forEach((([n,r])=>{const o=i.transitions[e.id]?.[n];o&&(s.transitions[n]=t({...e,id:o}).id)})),n.set(e.id,s),s}(t)}},t.StateMinimizer=class{constructor(t){this.automaton=t}minimize(){const{states:t,transitions:i,initialState:n,acceptingStates:e}=this.automaton;let s=this.initializePartitions(t,e),r=!0;for(;r;){r=!1;const t=this.splitPartitions(s,i);t.length!==s.length&&(r=!0),s=t}const o=s.map((t=>t[0])),a={};return o.forEach((t=>{a[t]={},Object.entries(i[t]).forEach((([i,n])=>{a[t][i]=this.findPartitionRepresentative(s,n)}))})),{states:o,transitions:a,initialState:this.findPartitionRepresentative(s,n),acceptingStates:e.filter((t=>o.includes(t)))}}initializePartitions(t,i){const n=t.filter((t=>!i.includes(t)));return[i,n]}splitPartitions(t,i){const n=[];return t.forEach((t=>{const e={};t.forEach((t=>{const n=JSON.stringify(i[t]);e[n]||(e[n]=[]),e[n].push(t)})),n.push(...Object.values(e))})),n}findPartitionRepresentative(t,i){return t.find((t=>t.includes(i)))?.[0]??i}}}));
//# sourceMappingURL=index.umd.js.map
