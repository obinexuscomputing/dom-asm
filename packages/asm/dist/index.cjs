"use strict";exports.StateMachine=class{constructor(t,i){this.currentState=t,this.transitions=i,this.states=new Set(i.flatMap((t=>[t.from,t.to]))),this.alphabet=new Set(i.map((t=>t.on)))}getCurrentState(){return this.currentState}transition(t){const i=this.transitions.find((i=>i.from===this.currentState&&i.on===t));if(!i)throw new Error(`Invalid transition from ${this.currentState} on ${t}`);this.currentState=i.to}minimize(){const t=new Set,i=new Set([...this.states].filter((t=>!this.isFinalState(t)))),n=new Set([...this.states].filter((t=>this.isFinalState(t))));t.add(i),t.add(n);let s=!0;for(;s;){s=!1;for(const i of t){const[n,...e]=[...i],r=new Set,a=new Set([n]);for(const i of e)this.areEquivalent(n,i,t)?a.add(i):(r.add(new Set([i])),s=!0);if(r.size>0){t.delete(i),t.add(a);for(const i of r)t.add(i)}}}this.updateTransitions(t)}isFinalState(t){return!1}areEquivalent(t,i,n){for(const s of this.alphabet){const e=this.getNextState(t,s),r=this.getNextState(i,s);if(e!==r&&!this.inSamePartition(e,r,n))return!1}return!0}getNextState(t,i){const n=this.transitions.find((n=>n.from===t&&n.on===i));return n?n.to:null}inSamePartition(t,i,n){if(t===i)return!0;for(const s of n)if(s.has(t)&&s.has(i))return!0;return!1}updateTransitions(t){const i=new Map;for(const n of t){const[t]=[...n];for(const s of n)i.set(s,t)}this.transitions=this.transitions.map((t=>({from:i.get(t.from),to:i.get(t.to),on:t.on}))),this.states=new Set(i.values()),this.currentState=i.get(this.currentState)}},exports.StateMachineAST=class{constructor(t,i){this.root=t,this.automaton=i}optimizeAST(){const t=new Map,i=n=>{if(t.has(n.id))return t.get(n.id);const s={...n,transitions:{}};return Object.entries(n.transitions).forEach((([t,e])=>{const r=this.automaton.transitions[n.id]?.[t];r&&(s.transitions[t]=i({...n,id:r}).id)})),t.set(n.id,s),s};return i(this.root)}},exports.StateMachineASTOptimizer=class{static optimizeAST(t,i){const n=new Map;return function t(s){if(n.has(s.id))return n.get(s.id);const e={...s,transitions:{}};return Object.entries(s.transitions).forEach((([n,r])=>{const a=i.transitions[s.id]?.[n];a&&(e.transitions[n]=t({...s,id:a}).id)})),n.set(s.id,e),e}(t)}},exports.StateMinimizer=class{constructor(t){this.automaton=t}minimize(){const{states:t,transitions:i,initialState:n,acceptingStates:s}=this.automaton;let e=this.initializePartitions(t,s),r=!0;for(;r;){r=!1;const t=this.splitPartitions(e,i);t.length!==e.length&&(r=!0),e=t}const a=e.map((t=>t[0])),o={};return a.forEach((t=>{o[t]={},Object.entries(i[t]).forEach((([i,n])=>{o[t][i]=this.findPartitionRepresentative(e,n)}))})),{states:a,transitions:o,initialState:this.findPartitionRepresentative(e,n),acceptingStates:s.filter((t=>a.includes(t)))}}initializePartitions(t,i){const n=t.filter((t=>!i.includes(t)));return[i,n]}splitPartitions(t,i){const n=[];return t.forEach((t=>{const s={};t.forEach((t=>{const n=JSON.stringify(i[t]);s[n]||(s[n]=[]),s[n].push(t)})),n.push(...Object.values(s))})),n}findPartitionRepresentative(t,i){return t.find((t=>t.includes(i)))?.[0]??i}};
//# sourceMappingURL=index.cjs.map
