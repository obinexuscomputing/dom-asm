{"version":3,"file":"index.cjs.js","sources":["../src/ast/index.ts","../src/optimizer/index.ts","../src/tokenizer/index.ts","../src/validator/index.ts"],"sourcesContent":["\r\nimport { Token } from \"../tokenizer\";\r\n\r\nexport type ASTNode = {\r\n  type: string; // e.g., 'stylesheet', 'rule', 'selector', 'declaration', 'value'\r\n  value?: string; // Optional value for the node, e.g., a selector name or property value\r\n  children: ASTNode[]; // Child nodes for nested structures\r\n};\r\n\r\n// Example usage:\r\n// import { Tokenizer } from \"../tokenizer\";\r\n\r\n// const cssInput = `/* Example CSS */\r\n// body {\r\n//   background: white;\r\n//   color: black;\r\n// }`;\r\n// const tokenizer = new Tokenizer(cssInput);\r\n// const tokens = tokenizer.tokenize();\r\n// const astBuilder = new ASTBuilder(tokens);\r\n// console.log(JSON.stringify(astBuilder.buildAST(), null, 2));\r\n\r\nexport class ASTBuilder {\r\n  private tokens: Token[];\r\n  private position: number;\r\n\r\n  constructor(tokens: Token[]) {\r\n    this.tokens = tokens;\r\n    this.position = 0;\r\n  }\r\n\r\n  private currentToken(): Token | null {\r\n    return this.position < this.tokens.length ? this.tokens[this.position] : null;\r\n  }\r\n\r\n  private consumeToken(): Token {\r\n    const token = this.currentToken();\r\n    if (token) this.position++;\r\n    return token!;\r\n  }\r\n\r\n  private parseStylesheet(): ASTNode {\r\n    const stylesheet: ASTNode = { type: 'stylesheet', children: [] };\r\n\r\n    while (this.currentToken()) {\r\n      const rule = this.parseRule();\r\n      if (rule) {\r\n        stylesheet.children.push(rule);\r\n      }\r\n    }\r\n\r\n    return stylesheet;\r\n  }\r\n\r\n  private parseRule(): ASTNode | null {\r\n    const selector = this.parseSelector();\r\n    if (!selector) return null;\r\n\r\n    const rule: ASTNode = { type: 'rule', children: [selector] };\r\n\r\n    const token = this.currentToken();\r\n    if (token?.type === 'other' && token.value === '{') {\r\n      this.consumeToken(); // Consume '{'\r\n      const declarations = this.parseDeclarations();\r\n      rule.children.push(...declarations);\r\n\r\n      const closingBrace = this.currentToken();\r\n      if (closingBrace?.type === 'other' && closingBrace.value === '}') {\r\n        this.consumeToken(); // Consume '}'\r\n      } else {\r\n        throw new Error(`Unexpected token: expected '}' but found ${closingBrace?.value}`);\r\n      }\r\n    }\r\n\r\n    return rule;\r\n  }\r\n\r\n  private parseSelector(): ASTNode | null {\r\n    const token = this.currentToken();\r\n    if (token?.type === 'other') {\r\n      this.consumeToken();\r\n      return { type: 'selector', value: token.value, children: [] };\r\n    }\r\n    return null;\r\n  }\r\n\r\n  private parseDeclarations(): ASTNode[] {\r\n    const declarations: ASTNode[] = [];\r\n\r\n    while (this.currentToken() && this.currentToken()?.value !== '}') {\r\n      const declaration = this.parseDeclaration();\r\n      if (declaration) {\r\n        declarations.push(declaration);\r\n      }\r\n    }\r\n\r\n    return declarations;\r\n  }\r\n\r\n  private parseDeclaration(): ASTNode | null {\r\n    const property = this.parseProperty();\r\n    if (!property) return null;\r\n\r\n    const token = this.currentToken();\r\n    if (token?.type === 'other' && token.value === ':') {\r\n      this.consumeToken(); // Consume ':'\r\n      const value = this.parseValue();\r\n\r\n      if (value) {\r\n        const declaration: ASTNode = { type: 'declaration', children: [property, value] };\r\n\r\n        const semicolon = this.currentToken();\r\n        if (semicolon?.type === 'other' && semicolon.value === ';') {\r\n          this.consumeToken(); // Consume ';'\r\n        }\r\n\r\n        return declaration;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  private parseProperty(): ASTNode | null {\r\n    const token = this.currentToken();\r\n    if (token?.type === 'other') {\r\n      this.consumeToken();\r\n      return { type: 'property', value: token.value, children: [] };\r\n    }\r\n    return null;\r\n  }\r\n\r\n  private parseValue(): ASTNode | null {\r\n    const token = this.currentToken();\r\n    if (token?.type === 'other') {\r\n      this.consumeToken();\r\n      return { type: 'value', value: token.value, children: [] };\r\n    }\r\n    return null;\r\n  }\r\n\r\n  public buildAST(): ASTNode {\r\n    return this.parseStylesheet();\r\n  }\r\n}\r\n\r\n// ","\r\nimport { ASTNode } from \"../ast\";\r\n\r\nexport class Optimizer {\r\n  private ast: ASTNode;\r\n\r\n  constructor(ast: ASTNode) {\r\n    this.ast = ast;\r\n  }\r\n\r\n  private removeDuplicateDeclarations(node: ASTNode): void {\r\n    if (node.type === 'rule') {\r\n      const declarations = node.children.filter((child) => child.type === 'declaration');\r\n      const uniqueDeclarations: Record<string, ASTNode> = {};\r\n\r\n      for (const declaration of declarations) {\r\n        const propertyNode = declaration.children.find((child) => child.type === 'property');\r\n        if (propertyNode && propertyNode.value) {\r\n          uniqueDeclarations[propertyNode.value] = declaration;\r\n        }\r\n      }\r\n\r\n      node.children = node.children.filter((child) => child.type !== 'declaration').concat(Object.values(uniqueDeclarations));\r\n    }\r\n\r\n    for (const child of node.children) {\r\n      this.removeDuplicateDeclarations(child);\r\n    }\r\n  }\r\n\r\n  private mergeAdjacentRules(node: ASTNode): void {\r\n    if (node.type === 'stylesheet') {\r\n      const ruleMap: Record<string, ASTNode> = {};\r\n\r\n      node.children = node.children.filter((child) => {\r\n        if (child.type === 'rule') {\r\n          const selector = child.children.find((c) => c.type === 'selector');\r\n          if (selector && selector.value) {\r\n            if (ruleMap[selector.value]) {\r\n              ruleMap[selector.value].children.push(\r\n                ...child.children.filter((c) => c.type === 'declaration')\r\n              );\r\n              return false;\r\n            } else {\r\n              ruleMap[selector.value] = child;\r\n            }\r\n          }\r\n        }\r\n        return true;\r\n      });\r\n    }\r\n\r\n    for (const child of node.children) {\r\n      this.mergeAdjacentRules(child);\r\n    }\r\n  }\r\n\r\n  public optimize(): ASTNode {\r\n    this.removeDuplicateDeclarations(this.ast);\r\n    this.mergeAdjacentRules(this.ast);\r\n    return this.ast;\r\n  }\r\n}\r\n","\r\nexport type Token = {\r\n    type: string; // e.g., 'selector', 'property', 'value', 'whitespace', 'comment'\r\n    value: string; // The actual content of the token\r\n    position: { line: number; column: number }; // For error reporting and debugging\r\n  };\r\n  \r\n   // Example usage:\r\n//   const cssInput = `/* Example CSS */\r\n//   body {\r\n//     background: white;\r\n//   }`;\r\n//   const tokenizer = new Tokenizer(cssInput);\r\n//   console.log(tokenizer.tokenize());\r\n  \r\n  export class Tokenizer {\r\n    private input: string;\r\n    private position: number;\r\n    private line: number;\r\n    private column: number;\r\n  \r\n    constructor(input: string) {\r\n      this.input = input;\r\n      this.position = 0;\r\n      this.line = 1;\r\n      this.column = 1;\r\n    }\r\n  \r\n    private isWhitespace(char: string): boolean {\r\n      return char === ' ' || char === '\\t' || char === '\\n' || char === '\\r';\r\n    }\r\n  \r\n    private isCommentStart(): boolean {\r\n      return this.input[this.position] === '/' && this.input[this.position + 1] === '*';\r\n    }\r\n  \r\n    private consumeWhitespace(): Token {\r\n      const start = this.position;\r\n      while (this.isWhitespace(this.input[this.position])) {\r\n        if (this.input[this.position] === '\\n') {\r\n          this.line++;\r\n          this.column = 1;\r\n        } else {\r\n          this.column++;\r\n        }\r\n        this.position++;\r\n      }\r\n      return {\r\n        type: 'whitespace',\r\n        value: this.input.slice(start, this.position),\r\n        position: { line: this.line, column: this.column },\r\n      };\r\n    }\r\n  \r\n    private consumeComment(): Token {\r\n      const start = this.position;\r\n      this.position += 2; // Skip '/*'\r\n      while (this.position < this.input.length && !(this.input[this.position] === '*' && this.input[this.position + 1] === '/')) {\r\n        if (this.input[this.position] === '\\n') {\r\n          this.line++;\r\n          this.column = 1;\r\n        } else {\r\n          this.column++;\r\n        }\r\n        this.position++;\r\n      }\r\n      this.position += 2; // Skip '*/'\r\n      return {\r\n        type: 'comment',\r\n        value: this.input.slice(start, this.position),\r\n        position: { line: this.line, column: this.column },\r\n      };\r\n    }\r\n  \r\n    private consumeOther(): Token {\r\n      const start = this.position;\r\n      while (this.position < this.input.length && !this.isWhitespace(this.input[this.position]) && !this.isCommentStart()) {\r\n        this.position++;\r\n        this.column++;\r\n      }\r\n      return {\r\n        type: 'other',\r\n        value: this.input.slice(start, this.position),\r\n        position: { line: this.line, column: this.column },\r\n      };\r\n    }\r\n  \r\n    public tokenize(): Token[] {\r\n      const tokens: Token[] = [];\r\n  \r\n      while (this.position < this.input.length) {\r\n        const char = this.input[this.position];\r\n  \r\n        if (this.isWhitespace(char)) {\r\n          tokens.push(this.consumeWhitespace());\r\n        } else if (this.isCommentStart()) {\r\n          tokens.push(this.consumeComment());\r\n        } else {\r\n          tokens.push(this.consumeOther());\r\n        }\r\n      }\r\n  \r\n      return tokens;\r\n    }\r\n  }\r\n  \r\n//  ","// Example usage:\r\n// import { Tokenizer } from \"../tokenizer\";\r\n// import { ASTBuilder } from \"../ast\";\r\n\r\n// const cssInput = `/* Example CSS */\r\n// body {\r\n//   background: white;\r\n//   color;\r\n// }`;\r\n// const tokenizer = new Tokenizer(cssInput);\r\n// const tokens = tokenizer.tokenize();\r\n// const astBuilder = new ASTBuilder(tokens);\r\n// const ast = astBuilder.buildAST();\r\n\r\n// const validator = new Validator(ast);\r\n// const errors = validator.validate();\r\n// if (errors.length > 0) {\r\n//   console.error(\"Validation errors:\", errors);\r\n// } else {\r\n//   console.log(\"CSS is valid.\");\r\n// }\r\n\r\nimport { ASTNode } from \"../ast\";\r\n\r\nexport class Validator {\r\n  private ast: ASTNode;\r\n  private errors: string[];\r\n\r\n  constructor(ast: ASTNode) {\r\n    this.ast = ast;\r\n    this.errors = [];\r\n  }\r\n\r\n  private validateStylesheet(node: ASTNode): void {\r\n    if (node.type !== 'stylesheet') {\r\n      this.errors.push(`Invalid root node type: ${node.type}`);\r\n    }\r\n\r\n    for (const child of node.children) {\r\n      if (child.type === 'rule') {\r\n        this.validateRule(child);\r\n      } else {\r\n        this.errors.push(`Invalid child node type in stylesheet: ${child.type}`);\r\n      }\r\n    }\r\n  }\r\n\r\n  private validateRule(node: ASTNode): void {\r\n    const selector = node.children.find((child) => child.type === 'selector');\r\n    if (!selector || !selector.value) {\r\n      this.errors.push(`Missing or invalid selector in rule.`);\r\n    }\r\n\r\n    const declarations = node.children.filter((child) => child.type === 'declaration');\r\n    for (const declaration of declarations) {\r\n      this.validateDeclaration(declaration);\r\n    }\r\n  }\r\n\r\n  private validateDeclaration(node: ASTNode): void {\r\n    const property = node.children.find((child) => child.type === 'property');\r\n    const value = node.children.find((child) => child.type === 'value');\r\n\r\n    if (!property || !property.value) {\r\n      this.errors.push(`Missing or invalid property in declaration.`);\r\n    }\r\n\r\n    if (!value || !value.value) {\r\n      this.errors.push(`Missing or invalid value in declaration.`);\r\n    }\r\n  }\r\n\r\n  public validate(): string[] {\r\n    this.validateStylesheet(this.ast);\r\n    return this.errors;\r\n  }\r\n}\r\n\r\n"],"names":["tokens","position","constructor","this","currentToken","length","consumeToken","token","parseStylesheet","stylesheet","type","children","rule","parseRule","push","selector","parseSelector","value","declarations","parseDeclarations","closingBrace","Error","declaration","parseDeclaration","property","parseProperty","parseValue","semicolon","buildAST","ast","removeDuplicateDeclarations","node","filter","child","uniqueDeclarations","propertyNode","find","concat","Object","values","mergeAdjacentRules","ruleMap","c","optimize","input","line","column","isWhitespace","char","isCommentStart","consumeWhitespace","start","slice","consumeComment","consumeOther","tokenize","errors","validateStylesheet","validateRule","validateDeclaration","validate"],"mappings":"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"}