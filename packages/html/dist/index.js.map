{"version":3,"file":"index.js","sources":["../src/tokenizer/HTMLTokenizer.ts","../src/parser/HTMLParser.ts","../src/validator/HTMLValidator.ts","../src/generator/HTMLCodeGenerator.ts","../src/ast/HTMLASTOptimizer.ts"],"sourcesContent":["export type HTMLToken =\r\n  | { type: \"Doctype\"; value: string; line: number; column: number }\r\n  | { type: \"StartTag\"; name: string; attributes: Record<string, string>; selfClosing: boolean; line: number; column: number }\r\n  | { type: \"EndTag\"; name: string; line: number; column: number }\r\n  | { type: \"Text\"; value: string; line: number; column: number }\r\n  | { type: \"Comment\"; value: string; line: number; column: number };\r\n\r\nexport class HTMLTokenizer {\r\n  private input: string;\r\n  private position: number = 0;\r\n  private line: number = 1;\r\n  private column: number = 1;\r\n  private lastTokenEnd: number = 0;\r\n\r\n  constructor(input: string) {\r\n    this.input = input;\r\n  }\r\n\r\n  public tokenize(): HTMLToken[] {\r\n    this.position = 0;\r\n    this.line = 1;\r\n    this.column = 1;\r\n    this.lastTokenEnd = 0;\r\n    \r\n    const tokens: HTMLToken[] = [];\r\n    let textStart = 0;\r\n    \r\n    while (this.position < this.input.length) {\r\n      const char = this.peek();\r\n\r\n      if (char === \"<\") {\r\n        // Handle text before tag\r\n        if (textStart < this.position) {\r\n          const textContent = this.input.slice(textStart, this.position);\r\n          const textToken = this.createTextToken(textContent, textStart);\r\n          if (this.isTextToken(textToken) && textToken.value) {\r\n            tokens.push(textToken);\r\n          }\r\n        }\r\n\r\n        const tagStart = this.position;\r\n        if (this.match(\"<!--\")) {\r\n          const commentToken = this.readComment();\r\n          if (this.isCommentToken(commentToken) && commentToken.value) {\r\n            tokens.push(commentToken);\r\n          }\r\n        } else if (this.match(\"<!DOCTYPE\")) {\r\n          tokens.push(this.readDoctype());\r\n        } else if (this.peek(1) === \"/\") {\r\n          const endTag = this.readEndTag();\r\n          tokens.push({\r\n            ...endTag,\r\n            column: this.getColumnAtPosition(tagStart)\r\n          });\r\n        } else {\r\n          tokens.push(this.readStartTag());\r\n        }\r\n        \r\n        textStart = this.position;\r\n        this.lastTokenEnd = this.position;\r\n      } else {\r\n        this.position++;\r\n        if (char === '\\n') {\r\n          this.line++;\r\n          this.column = 1;\r\n        } else {\r\n          this.column++;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Handle any remaining text\r\n    if (textStart < this.position) {\r\n      const textContent = this.input.slice(textStart, this.position);\r\n      const textToken = this.createTextToken(textContent, textStart);\r\n      if (this.isTextToken(textToken) && textToken.value) {\r\n        tokens.push(textToken);\r\n      }\r\n    }\r\n\r\n    return tokens;\r\n  }\r\n\r\n  private isTextToken(token: HTMLToken): token is Extract<HTMLToken, { type: \"Text\" }> {\r\n    return token.type === \"Text\";\r\n  }\r\n\r\n  private isCommentToken(token: HTMLToken): token is Extract<HTMLToken, { type: \"Comment\" }> {\r\n    return token.type === \"Comment\";\r\n  }\r\n\r\n  private createTextToken(content: string, startPos: number): HTMLToken {\r\n    let line = 1;\r\n    let lastNewline = -1;\r\n    \r\n    for (let i = 0; i < startPos; i++) {\r\n      if (this.input[i] === '\\n') {\r\n        line++;\r\n        lastNewline = i;\r\n      }\r\n    }\r\n    \r\n    const column = lastNewline === -1 ? startPos + 1 : startPos - lastNewline;\r\n    \r\n    return {\r\n      type: \"Text\" as const,\r\n      value: content.trim(),\r\n      line,\r\n      column\r\n    };\r\n  }\r\n\r\n  private readStartTag(): HTMLToken {\r\n    const { line, column } = this.getCurrentLocation();\r\n    this.consume(); // Skip '<'\r\n    \r\n    const name = this.readTagName();\r\n    const attributes: Record<string, string> = {};\r\n    let selfClosing = false;\r\n    \r\n    while (this.position < this.input.length && !this.match(\">\")) {\r\n      this.skipWhitespace();\r\n      \r\n      if (this.match(\"/>\")) {\r\n        selfClosing = true;\r\n        this.position += 2;\r\n        this.column += 2;\r\n        break;\r\n      }\r\n      \r\n      if (this.peek() === \"/\") {\r\n        selfClosing = true;\r\n        this.consume();\r\n        continue;\r\n      }\r\n      \r\n      const attrName = this.readUntil(/[\\s=\\/>]/).trim();\r\n      if (!attrName) break;\r\n      \r\n      this.skipWhitespace();\r\n      \r\n      if (this.peek() === \"=\") {\r\n        this.consume(); // Skip '='\r\n        this.skipWhitespace();\r\n        \r\n        let value: string;\r\n        const quote = this.peek();\r\n        \r\n        if (quote === '\"' || quote === \"'\") {\r\n          this.consume(); // Skip opening quote\r\n          value = this.readUntil(quote);\r\n          this.consume(); // Skip closing quote\r\n        } else {\r\n          value = this.readUntil(/[\\s\\/>]/);\r\n        }\r\n        \r\n        attributes[attrName] = value;\r\n      } else {\r\n        attributes[attrName] = \"true\";\r\n      }\r\n      \r\n      this.skipWhitespace();\r\n    }\r\n    \r\n    if (this.peek() === \">\") {\r\n      this.consume();\r\n    }\r\n    \r\n    return { type: \"StartTag\", name, attributes, selfClosing, line, column };\r\n  }\r\n\r\n  private readEndTag(): HTMLToken {\r\n    const { line, column } = this.getCurrentLocation();\r\n    this.consume(2); // Skip '</'\r\n    \r\n    const name = this.readTagName();\r\n    this.skipWhitespace();\r\n    \r\n    if (this.peek() === \">\") {\r\n      this.consume();\r\n    }\r\n    \r\n    return { type: \"EndTag\", name, line, column };\r\n  }\r\n\r\n  private readComment(): HTMLToken {\r\n    const { line, column } = this.getCurrentLocation();\r\n    this.consume(4); // Skip '<!--'\r\n    \r\n    let value = '';\r\n    while (this.position < this.input.length) {\r\n      if (this.match(\"-->\")) {\r\n        break;\r\n      }\r\n      value += this.consume();\r\n    }\r\n    \r\n    this.consume(3); // Skip '-->'\r\n    return { type: \"Comment\", value: value.trim(), line, column };\r\n  }\r\n\r\n  private readDoctype(): HTMLToken {\r\n    const { line, column } = this.getCurrentLocation();\r\n    this.consume(9); // Skip '<!DOCTYPE'\r\n    const value = this.readUntil(\">\").trim();\r\n    this.consume(); // Skip '>'\r\n    return { type: \"Doctype\", value, line, column };\r\n  }\r\n\r\n  private readTagName(): string {\r\n    let name = '';\r\n    while (this.position < this.input.length && !/[\\s>\\/]/.test(this.peek())) {\r\n      name += this.input[this.position];\r\n      this.position++;\r\n      this.column++;\r\n    }\r\n    return name.toLowerCase().trim();\r\n  }\r\n\r\n  private getColumnAtPosition(pos: number): number {\r\n    let lastNewline = this.input.lastIndexOf('\\n', pos - 1);\r\n    return lastNewline === -1 ? pos + 1 : pos - lastNewline;\r\n  }\r\n\r\n  private peek(offset: number = 0): string {\r\n    return this.input[this.position + offset] || '';\r\n  }\r\n\r\n  private match(str: string): boolean {\r\n    return this.input.startsWith(str, this.position);\r\n  }\r\n\r\n  private readUntil(stop: string | RegExp): string {\r\n    const start = this.position;\r\n    while (this.position < this.input.length) {\r\n      const char = this.peek();\r\n      if (typeof stop === 'string' ? char === stop : stop.test(char)) {\r\n        break;\r\n      }\r\n      this.consume();\r\n    }\r\n    return this.input.slice(start, this.position);\r\n  }\r\n\r\n  private consume(count: number = 1): string {\r\n    let result = '';\r\n    for (let i = 0; i < count && this.position < this.input.length; i++) {\r\n      const char = this.input[this.position];\r\n      result += char;\r\n      \r\n      if (char === '\\n') {\r\n        this.line++;\r\n        this.column = 1;\r\n      } else {\r\n        this.column++;\r\n      }\r\n      \r\n      this.position++;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  private skipWhitespace(): void {\r\n    while (this.position < this.input.length && /\\s/.test(this.peek())) {\r\n      this.consume();\r\n    }\r\n  }\r\n\r\n  private getCurrentLocation(): { line: number; column: number } {\r\n    return { line: this.line, column: this.column };\r\n  }\r\n}","import { HTMLAST, HTMLASTNode } from \"../ast/HTMLAST\";\r\nimport { HTMLToken, HTMLTokenizer } from \"../tokenizer/HTMLTokenizer\";\r\n\r\nexport class HTMLParserError extends Error {\r\n  constructor(\r\n    message: string,\r\n    public token: HTMLToken,\r\n    public position: number\r\n  ) {\r\n    super(message);\r\n    this.name = \"HTMLParserError\";\r\n  }\r\n}\r\n\r\nexport interface HTMLParserOptions {\r\n  throwOnError?: boolean;\r\n  errorHandler?: (error: HTMLParserError) => void;\r\n}\r\n\r\nexport class HTMLParser {\r\n  private tokenizer: HTMLTokenizer;\r\n  private options: HTMLParserOptions;\r\n\r\n  constructor(options: HTMLParserOptions = { throwOnError: true }) {\r\n    this.tokenizer = new HTMLTokenizer(\"\");\r\n    this.options = options;\r\n  }\r\n\r\n  public parse(input: string): HTMLAST {\r\n    this.tokenizer = new HTMLTokenizer(input);\r\n    const tokens = this.tokenizer.tokenize();\r\n    \r\n    try {\r\n      const root = this.buildAST(tokens);\r\n      return {\r\n        root,\r\n        metadata: this.computeMetadata(root)\r\n      };\r\n    } catch (error) {\r\n      if (this.options.throwOnError) {\r\n        throw error;\r\n      }\r\n\r\n      if (this.options.errorHandler) {\r\n        this.options.errorHandler(error as HTMLParserError);\r\n      }\r\n\r\n      // Return a valid but empty AST for recovery\r\n      return {\r\n        root: {\r\n          type: \"Element\",\r\n          name: \"root\",\r\n          children: [],\r\n          attributes: {}\r\n        },\r\n        metadata: {\r\n          nodeCount: 1,\r\n          elementCount: 1,\r\n          textCount: 0,\r\n          commentCount: 0\r\n        }\r\n      };\r\n    }\r\n  }\r\n\r\n  private buildAST(tokens: HTMLToken[]): HTMLASTNode {\r\n    const root: HTMLASTNode = {\r\n      type: \"Element\",\r\n      name: \"root\",\r\n      children: [],\r\n      attributes: {}\r\n    };\r\n\r\n    const stack: HTMLASTNode[] = [root];\r\n    let currentParent = root;\r\n\r\n    for (let i = 0; i < tokens.length; i++) {\r\n      const token = tokens[i];\r\n\r\n      try {\r\n        switch (token.type) {\r\n          case \"StartTag\": {\r\n            const element: HTMLASTNode = {\r\n              type: \"Element\",\r\n              name: token.name,\r\n              attributes: token.attributes || {},\r\n              children: []\r\n            };\r\n\r\n            currentParent.children.push(element);\r\n            \r\n            if (!token.selfClosing) {\r\n              stack.push(element);\r\n              currentParent = element;\r\n            }\r\n            break;\r\n          }\r\n\r\n          case \"EndTag\": {\r\n            if (stack.length <= 1) {\r\n              this.handleError(new HTMLParserError(\r\n                `Unexpected closing tag \"${token.name}\"`,\r\n                token,\r\n                i\r\n              ));\r\n              continue;\r\n            }\r\n\r\n            if (currentParent.name !== token.name) {\r\n              this.handleError(new HTMLParserError(\r\n                `Mismatched tags: expected \"${currentParent.name}\", got \"${token.name}\"`,\r\n                token,\r\n                i\r\n              ));\r\n              continue;\r\n            }\r\n\r\n            stack.pop();\r\n            currentParent = stack[stack.length - 1];\r\n            break;\r\n          }\r\n\r\n          case \"Text\": {\r\n            if (token.value?.trim()) {\r\n              currentParent.children.push({\r\n                type: \"Text\",\r\n                value: token.value,\r\n                children: []\r\n              });\r\n            }\r\n            break;\r\n          }\r\n\r\n          case \"Comment\": {\r\n            currentParent.children.push({\r\n              type: \"Comment\",\r\n              value: token.value || \"\",\r\n              children: []\r\n            });\r\n            break;\r\n          }\r\n        }\r\n      } catch (error) {\r\n        this.handleError(error as HTMLParserError);\r\n      }\r\n    }\r\n\r\n    // Handle unclosed tags\r\n    if (stack.length > 1) {\r\n      const lastToken = tokens[tokens.length - 1];\r\n      this.handleError(new HTMLParserError(\r\n        \"Unclosed tags detected\",\r\n        lastToken,\r\n        tokens.length - 1\r\n      ));\r\n    }\r\n\r\n    return root;\r\n  }\r\n\r\n  private handleError(error: HTMLParserError): void {\r\n    if (this.options.errorHandler) {\r\n      this.options.errorHandler(error);\r\n    }\r\n    if (this.options.throwOnError) {\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  private computeMetadata(root: HTMLASTNode): HTMLAST[\"metadata\"] {\r\n    let nodeCount = 0;\r\n    let elementCount = 0;\r\n    let textCount = 0;\r\n    let commentCount = 0;\r\n\r\n    const traverse = (node: HTMLASTNode) => {\r\n      nodeCount++;\r\n      switch (node.type) {\r\n        case \"Element\":\r\n          elementCount++;\r\n          node.children?.forEach(traverse);\r\n          break;\r\n        case \"Text\":\r\n          textCount++;\r\n          break;\r\n        case \"Comment\":\r\n          commentCount++;\r\n          break;\r\n      }\r\n    };\r\n\r\n    traverse(root);\r\n\r\n    return {\r\n      nodeCount,\r\n      elementCount,\r\n      textCount,\r\n      commentCount\r\n    };\r\n  }\r\n\r\n  public setErrorHandler(handler: (error: HTMLParserError) => void): void {\r\n    this.options.errorHandler = handler;\r\n  }\r\n}","import { HTMLASTNode } from \"../ast/HTMLAST\";\r\n\r\n// Specification types\r\ntype HTMLSpec = 'html5' | 'html6-xml';\r\n\r\ninterface ValidationOptions {\r\n  spec?: HTMLSpec;\r\n  strictMode?: boolean;\r\n  allowCustomElements?: boolean;\r\n  allowNamespaces?: boolean;\r\n  customNamespaces?: string[];\r\n}\r\n\r\ninterface ValidationContext {\r\n  parentTag?: string;\r\n  ancestors: string[];\r\n  inHead: boolean;\r\n  inBody: boolean;\r\n  hasHtml: boolean;\r\n  hasHead: boolean;\r\n  hasBody: boolean;\r\n  hasTitle: boolean;\r\n  contentCategories: Set<string>;\r\n}\r\n\r\nexport interface HTMLValidationResult {\r\n  valid: boolean;\r\n  errors: ValidationError[];\r\n  warnings: ValidationWarning[];\r\n}\r\n\r\ninterface ValidationError {\r\n  type: 'error';\r\n  message: string;\r\n  node?: HTMLASTNode;\r\n  code: string;\r\n}\r\n\r\ninterface ValidationWarning {\r\n  type: 'warning';\r\n  message: string;\r\n  node?: HTMLASTNode;\r\n  code: string;\r\n}\r\n/**\r\n * const validator = new HTMLValidator({\r\n  spec: 'html6-xml',\r\n  strictMode: true,\r\n  allowCustomElements: true,\r\n  allowNamespaces: true,\r\n  customNamespaces: ['html', 'custom']\r\n});\r\n\r\nconst result = validator.validate(ast);\r\nif (!result.valid) {\r\n  result.errors.forEach(error => {\r\n    console.error(`${error.code}: ${error.message}`);\r\n  });\r\n  result.warnings.forEach(warning => {\r\n    console.warn(`${warning.code}: ${warning.message}`);\r\n  });\r\n}\r\n */\r\nexport class HTMLValidator {\r\n  private readonly voidElements = new Set([\r\n    'area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input',\r\n    'link', 'meta', 'param', 'source', 'track', 'wbr'\r\n  ]);\r\n\r\n  private readonly flowContent = new Set([\r\n    'a', 'abbr', 'address', 'article', 'aside', 'audio', 'b',\r\n    'bdi', 'bdo', 'blockquote', 'br', 'button', 'canvas', 'cite',\r\n    'code', 'data', 'datalist', 'del', 'details', 'dfn', 'div',\r\n    'dl', 'em', 'embed', 'fieldset', 'figure', 'footer', 'form',\r\n    'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hr', 'i',\r\n    'iframe', 'img', 'input', 'ins', 'kbd', 'label', 'main',\r\n    'map', 'mark', 'math', 'meter', 'nav', 'noscript', 'object',\r\n    'ol', 'output', 'p', 'picture', 'pre', 'progress', 'q',\r\n    'ruby', 's', 'samp', 'script', 'section', 'select', 'small',\r\n    'span', 'strong', 'sub', 'sup', 'svg', 'table', 'template',\r\n    'textarea', 'time', 'u', 'ul', 'var', 'video', 'wbr'\r\n  ]);\r\n\r\n  private readonly metadataContent = new Set([\r\n    'base', 'link', 'meta', 'noscript', 'script', 'style', 'template', 'title'\r\n  ]);\r\n\r\n  private readonly defaultOptions: ValidationOptions = {\r\n    spec: 'html5',\r\n    strictMode: false,\r\n    allowCustomElements: true,\r\n    allowNamespaces: false,\r\n    customNamespaces: []\r\n  };\r\n\r\n  constructor(private options: ValidationOptions = {}) {\r\n    this.options = { ...this.defaultOptions, ...options };\r\n  }\r\n\r\n  public validate(ast: HTMLASTNode): HTMLValidationResult {\r\n    const context: ValidationContext = {\r\n      ancestors: [],\r\n      inHead: false,\r\n      inBody: false,\r\n      hasHtml: false,\r\n      hasHead: false,\r\n      hasBody: false,\r\n      hasTitle: false,\r\n      contentCategories: new Set()\r\n    };\r\n\r\n    const errors: ValidationError[] = [];\r\n    const warnings: ValidationWarning[] = [];\r\n\r\n    this.validateNode(ast, context, errors, warnings);\r\n\r\n    if (this.options.strictMode) {\r\n      this.validateDocumentStructure(context, errors);\r\n    }\r\n\r\n    return {\r\n      valid: errors.length === 0,\r\n      errors,\r\n      warnings\r\n    };\r\n  }\r\n\r\n  private validateNode(\r\n    node: HTMLASTNode,\r\n    context: ValidationContext,\r\n    errors: ValidationError[],\r\n    warnings: ValidationWarning[]\r\n  ): void {\r\n    if (node.type === 'Element') {\r\n      this.validateElement(node, context, errors, warnings);\r\n      \r\n      // Track document structure\r\n      this.updateDocumentContext(node, context);\r\n      \r\n      // Validate children\r\n      const prevContext = { ...context };\r\n      context.ancestors.push(node.name || '');\r\n      context.parentTag = node.name;\r\n      \r\n      node.children?.forEach(child => {\r\n        this.validateNode(child, context, errors, warnings);\r\n      });\r\n      \r\n      context.ancestors.pop();\r\n      context.parentTag = prevContext.parentTag;\r\n    }\r\n  }\r\n\r\n  private validateElement(\r\n    node: HTMLASTNode,\r\n    context: ValidationContext,\r\n    errors: ValidationError[],\r\n    warnings: ValidationWarning[]\r\n  ): void {\r\n    if (!node.name) {\r\n      errors.push({\r\n        type: 'error',\r\n        message: 'Element must have a name',\r\n        node,\r\n        code: 'E001'\r\n      });\r\n      return;\r\n    }\r\n\r\n    // Validate tag name\r\n    this.validateTagName(node, context, errors, warnings);\r\n\r\n    // Validate attributes\r\n    if (node.attributes) {\r\n      this.validateAttributes(node, context, errors, warnings);\r\n    }\r\n\r\n    // Validate content model\r\n    this.validateContentModel(node, context, errors, warnings);\r\n\r\n    // Validate void elements\r\n    if (this.voidElements.has(node.name.toLowerCase()) && node.children?.length) {\r\n      errors.push({\r\n        type: 'error',\r\n        message: `Void element <${node.name}> cannot have children`,\r\n        node,\r\n        code: 'E002'\r\n      });\r\n    }\r\n  }\r\n\r\n  private validateTagName(\r\n    node: HTMLASTNode,\r\n    context: ValidationContext,\r\n    errors: ValidationError[],\r\n    warnings: ValidationWarning[]\r\n  ): void {\r\n    const name = node.name || '';\r\n    \r\n    if (this.options.spec === 'html6-xml') {\r\n      // XML name validation\r\n      if (!name.match(/^([a-zA-Z_][\\w.-]*:)?[a-zA-Z_][\\w.-]*$/)) {\r\n        errors.push({\r\n          type: 'error',\r\n          message: `Invalid XML tag name: ${name}`,\r\n          node,\r\n          code: 'E003'\r\n        });\r\n      }\r\n\r\n      // Namespace validation\r\n      if (name.includes(':')) {\r\n        const [namespace] = name.split(':');\r\n        if (!this.options.allowNamespaces) {\r\n          errors.push({\r\n            type: 'error',\r\n            message: `Namespaces are not allowed: ${namespace}`,\r\n            node,\r\n            code: 'E004'\r\n          });\r\n        } else if (\r\n          this.options.customNamespaces &&\r\n          !this.options.customNamespaces.includes(namespace)\r\n        ) {\r\n          errors.push({\r\n            type: 'error',\r\n            message: `Unknown namespace: ${namespace}`,\r\n            node,\r\n            code: 'E005'\r\n          });\r\n        }\r\n      }\r\n    } else {\r\n      // HTML5 validation\r\n      if (!this.options.allowCustomElements && !this.isValidHTML5TagName(name)) {\r\n        errors.push({\r\n          type: 'error',\r\n          message: `Invalid HTML5 tag name: ${name}`,\r\n          node,\r\n          code: 'E006'\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  private validateAttributes(\r\n    node: HTMLASTNode,\r\n    context: ValidationContext,\r\n    errors: ValidationError[],\r\n    warnings: ValidationWarning[]\r\n  ): void {\r\n    const attributes = node.attributes || {};\r\n    \r\n    for (const [name, value] of Object.entries(attributes)) {\r\n      // XML attribute name validation\r\n      if (this.options.spec === 'html6-xml') {\r\n        if (!name.match(/^[a-zA-Z_][\\w.-]*$/)) {\r\n          errors.push({\r\n            type: 'error',\r\n            message: `Invalid XML attribute name: ${name}`,\r\n            node,\r\n            code: 'E007'\r\n          });\r\n        }\r\n      }\r\n\r\n      // HTML5 specific attribute validation\r\n      if (this.options.spec === 'html5') {\r\n        if (name.startsWith('on') && !this.isValidEventHandler(name)) {\r\n          warnings.push({\r\n            type: 'warning',\r\n            message: `Suspicious event handler attribute: ${name}`,\r\n            node,\r\n            code: 'W001'\r\n          });\r\n        }\r\n      }\r\n\r\n      // Common attribute validation\r\n      if (typeof value !== 'string') {\r\n        errors.push({\r\n          type: 'error',\r\n          message: `Attribute \"${name}\" must have a string value`,\r\n          node,\r\n          code: 'E008'\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  private validateContentModel(\r\n    node: HTMLASTNode,\r\n    context: ValidationContext,\r\n    errors: ValidationError[],\r\n    warnings: ValidationWarning[]\r\n  ): void {\r\n    const name = node.name?.toLowerCase();\r\n    \r\n    if (!name) return;\r\n\r\n    // Validate specific element content models\r\n    switch (name) {\r\n      case 'title':\r\n        if (!node.children?.length || node.children.length > 1) {\r\n          errors.push({\r\n            type: 'error',\r\n            message: '<title> must have exactly one text node child',\r\n            node,\r\n            code: 'E009'\r\n          });\r\n        }\r\n        break;\r\n\r\n      case 'head':\r\n        if (!context.hasTitle && this.options.strictMode) {\r\n          errors.push({\r\n            type: 'error',\r\n            message: '<head> must contain a <title> element',\r\n            node,\r\n            code: 'E010'\r\n          });\r\n        }\r\n        break;\r\n    }\r\n\r\n    // Validate parent-child relationships\r\n    if (context.parentTag) {\r\n      if (!this.isValidChild(context.parentTag, name)) {\r\n        errors.push({\r\n          type: 'error',\r\n          message: `<${name}> is not allowed as a child of <${context.parentTag}>`,\r\n          node,\r\n          code: 'E011'\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  private updateDocumentContext(node: HTMLASTNode, context: ValidationContext): void {\r\n    const name = node.name?.toLowerCase();\r\n    \r\n    if (!name) return;\r\n\r\n    switch (name) {\r\n      case 'html':\r\n        context.hasHtml = true;\r\n        break;\r\n      case 'head':\r\n        context.hasHead = true;\r\n        context.inHead = true;\r\n        break;\r\n      case 'body':\r\n        context.hasBody = true;\r\n        context.inBody = true;\r\n        break;\r\n      case 'title':\r\n        context.hasTitle = true;\r\n        break;\r\n    }\r\n  }\r\n\r\n  private validateDocumentStructure(\r\n    context: ValidationContext,\r\n    errors: ValidationError[]\r\n  ): void {\r\n    if (!context.hasHtml) {\r\n      errors.push({\r\n        type: 'error',\r\n        message: 'Document must have an <html> root element',\r\n        code: 'E012'\r\n      });\r\n    }\r\n\r\n    if (!context.hasHead) {\r\n      errors.push({\r\n        type: 'error',\r\n        message: 'Document must have a <head> element',\r\n        code: 'E013'\r\n      });\r\n    }\r\n\r\n    if (!context.hasBody) {\r\n      errors.push({\r\n        type: 'error',\r\n        message: 'Document must have a <body> element',\r\n        code: 'E014'\r\n      });\r\n    }\r\n  }\r\n\r\n  private isValidHTML5TagName(name: string): boolean {\r\n    // Standard HTML5 elements\r\n    const standardElements = new Set([...this.flowContent, ...this.metadataContent]);\r\n    return standardElements.has(name.toLowerCase());\r\n  }\r\n\r\n  private isValidEventHandler(name: string): boolean {\r\n    const validEvents = new Set([\r\n      'onclick', 'onload', 'onsubmit', 'onchange', 'onkeyup', 'onkeydown',\r\n      'onmouseover', 'onmouseout', 'onfocus', 'onblur'\r\n    ]);\r\n    return validEvents.has(name.toLowerCase());\r\n  }\r\n\r\n  private isValidChild(parent: string, child: string): boolean {\r\n    parent = parent.toLowerCase();\r\n    child = child.toLowerCase();\r\n\r\n    // Basic content model rules\r\n    const contentModel: Record<string, Set<string>> = {\r\n      head: this.metadataContent,\r\n      body: this.flowContent,\r\n      // Add more specific rules as needed\r\n    };\r\n\r\n    return !contentModel[parent] || contentModel[parent].has(child);\r\n  }\r\n}","import { HTMLASTNode } from \"../ast/HTMLAST\";\r\n\r\nexport class HTMLCodeGenerator {\r\n  private selfClosingTags: string[];\r\n\r\n  constructor(selfClosingTags: string[] = [\"img\", \"input\", \"br\", \"hr\", \"meta\", \"link\"]) {\r\n    this.selfClosingTags = selfClosingTags;\r\n  }\r\n\r\n  public generateHTML(node: HTMLASTNode): string {\r\n    if (node.type === \"Text\") {\r\n      return node.value || \"\";\r\n    }\r\n\r\n    if (node.type === \"Comment\") {\r\n      return `<!-- ${node.value || \"\"} -->`;\r\n    }\r\n\r\n    if (node.type === \"Element\") {\r\n      const attributes = this.generateAttributes(node.attributes || {});\r\n      const children = node.children?.map((child: HTMLASTNode) => this.generateHTML(child)).join(\"\") || \"\";\r\n\r\n      if (this.isSelfClosingTag(node.name)) {\r\n        return `<${node.name}${attributes} />`;\r\n      }\r\n\r\n      return `<${node.name}${attributes}>${children}</${node.name}>`;\r\n    }\r\n\r\n    return \"\";\r\n  }\r\n\r\n  private generateAttributes(attributes: Record<string, string>): string {\r\n    return Object.entries(attributes)\r\n      .map(([key, value]) => ` ${key}=\"${value}\"`)\r\n      .join(\"\");\r\n  }\r\n\r\n  private isSelfClosingTag(tagName?: string): boolean {\r\n    return this.selfClosingTags.includes(tagName || \"\");\r\n  }\r\n}\r\n","import { HTMLAST, HTMLASTNode } from \"../ast/HTMLAST\";\r\n\r\nexport class HTMLASTOptimizer {\r\n  public optimize(ast: HTMLAST): void {\r\n    if (!ast.root) return;\r\n    this.removeEmptyTextNodes(ast.root);\r\n    this.mergeTextNodes(ast.root);\r\n  }\r\n\r\n  private removeEmptyTextNodes(node: HTMLASTNode): void {\r\n    if (!node.children) return;\r\n\r\n    // Filter out empty text nodes, but preserve significant whitespace\r\n    node.children = node.children.filter((child) => {\r\n      if (child.type === \"Text\") {\r\n        return child.value != null && (child.value.trim() !== \"\" || this.isSignificantWhitespace(child, node.children));\r\n      }\r\n      return true;\r\n    });\r\n\r\n    // Process children recursively\r\n    node.children.forEach(child => {\r\n      if (child.type === \"Element\") {\r\n        this.removeEmptyTextNodes(child);\r\n      }\r\n    });\r\n  }\r\n\r\n  private isSignificantWhitespace(node: HTMLASTNode, siblings: HTMLASTNode[]): boolean {\r\n    if (node.type !== \"Text\" || !node.value) return false;\r\n    const index = siblings.indexOf(node);\r\n    \r\n    // Check if this whitespace is between elements or before/after element\r\n    const prev = index > 0 ? siblings[index - 1] : null;\r\n    const next = index < siblings.length - 1 ? siblings[index + 1] : null;\r\n    \r\n    return (prev?.type === \"Element\" || next?.type === \"Element\");\r\n  }\r\n\r\n  private mergeTextNodes(node: HTMLASTNode): void {\r\n    if (!node.children) return;\r\n\r\n    // Process child elements first (depth-first)\r\n    node.children.forEach(child => {\r\n      if (child.type === \"Element\") {\r\n        this.mergeTextNodes(child);\r\n      }\r\n    });\r\n\r\n    for (let i = 0; i < node.children.length - 1; i++) {\r\n      const current = node.children[i];\r\n      const next = node.children[i + 1];\r\n\r\n      if (current.type === \"Text\" && next.type === \"Text\") {\r\n        const currentText = current.value || \"\";\r\n        const nextText = next.value || \"\";\r\n        \r\n        // Special handling for trailing spaces\r\n        if (!nextText.trim()) {\r\n          // If next node is pure whitespace, preserve it exactly\r\n          current.value = currentText + nextText;\r\n        } else if (!currentText.trim()) {\r\n          // If current node is pure whitespace, preserve it exactly\r\n          current.value = currentText + nextText;\r\n        } else {\r\n          // Both nodes have content\r\n          const needsSpace = !currentText.endsWith(\" \") && !nextText.startsWith(\" \");\r\n          current.value = currentText + (needsSpace ? \" \" : \"\") + nextText;\r\n        }\r\n        \r\n        // Remove the merged node\r\n        node.children.splice(i + 1, 1);\r\n        i--; // Recheck current position as we removed an element\r\n      }\r\n    }\r\n  }\r\n\r\n  private shouldPreserveWhitespace(text: string, isLast: boolean): boolean {\r\n    // Preserve trailing spaces in specific cases\r\n    return text.endsWith(\" \") && isLast;\r\n  }\r\n}"],"names":["HTMLTokenizer","constructor","input","this","position","line","column","lastTokenEnd","tokenize","tokens","textStart","length","char","peek","textContent","slice","textToken","createTextToken","isTextToken","value","push","tagStart","match","commentToken","readComment","isCommentToken","readDoctype","endTag","readEndTag","getColumnAtPosition","readStartTag","token","type","content","startPos","lastNewline","i","trim","getCurrentLocation","consume","name","readTagName","attributes","selfClosing","skipWhitespace","attrName","readUntil","quote","test","toLowerCase","pos","lastIndexOf","offset","str","startsWith","stop","start","count","result","HTMLParserError","Error","message","super","HTMLParser","options","throwOnError","tokenizer","parse","root","buildAST","metadata","computeMetadata","error","errorHandler","children","nodeCount","elementCount","textCount","commentCount","stack","currentParent","element","handleError","pop","lastToken","traverse","node","forEach","setErrorHandler","handler","HTMLValidator","voidElements","Set","flowContent","metadataContent","defaultOptions","spec","strictMode","allowCustomElements","allowNamespaces","customNamespaces","validate","ast","context","ancestors","inHead","inBody","hasHtml","hasHead","hasBody","hasTitle","contentCategories","errors","warnings","validateNode","validateDocumentStructure","valid","validateElement","updateDocumentContext","prevContext","parentTag","child","validateTagName","validateAttributes","validateContentModel","has","code","includes","namespace","split","isValidHTML5TagName","Object","entries","isValidEventHandler","isValidChild","parent","contentModel","head","body","HTMLCodeGenerator","selfClosingTags","generateHTML","generateAttributes","map","join","isSelfClosingTag","key","tagName","HTMLASTOptimizer","optimize","removeEmptyTextNodes","mergeTextNodes","filter","isSignificantWhitespace","siblings","index","indexOf","prev","next","current","currentText","nextText","needsSpace","endsWith","splice","shouldPreserveWhitespace","text","isLast"],"mappings":"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"}