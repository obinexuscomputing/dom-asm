"use strict";class t{root;constructor(){this.root={type:"Element",name:"root",children:[],parent:null}}buildAST(t){const e=[this.root];let i=this.root;for(const n of t)switch(n.type){case"StartTag":const t={type:"Element",name:n.name,attributes:n.attributes,children:[],parent:i};i.children.push(t),e.push(t),i=t;break;case"EndTag":if(i.name!==n.name)throw new Error(`Unmatched end tag: </${n.name}>. Expected </${i.name}>.`);e.pop(),i=e[e.length-1];break;case"Text":const r={type:"Text",value:n.value,children:[],parent:i};i.children.push(r);break;case"Comment":const s={type:"Comment",value:n.value,children:[],parent:i};i.children.push(s);break;default:throw new Error(`Unsupported token type: ${n}`)}return this.root}getRoot(){return this.root}printAST(t=this.root,e=0){const i="  ".repeat(e);"Element"===t.type?(console.log(`${i}<${t.name}>`),t.children.forEach((t=>this.printAST(t,e+1))),console.log(`${i}</${t.name}>`)):"Text"===t.type?console.log(`${i}${t.value}`):"Comment"===t.type&&console.log(`${i}\x3c!-- ${t.value} --\x3e`)}}var e;exports.TokenType=void 0,(e=exports.TokenType||(exports.TokenType={})).Keyword="keyword",e.Identifier="identifier",e.Number="number",e.String="string";class i{input;position=0;constructor(t){this.input=t}tokenize(){const t=[];for(;this.position<this.input.length;){"<"===this.input[this.position]?"/"===this.input[this.position+1]?t.push(this.readEndTag()):"!"===this.input[this.position+1]?t.push(this.readComment()):t.push(this.readStartTag()):t.push(this.readText())}return t}readStartTag(){this.position++;const t=this.readUntil(/[ \/>]/),e={};for(;">"!==this.input[this.position]&&"/"!==this.input[this.position];){const t=this.readUntil("=").trim();this.position++;const i=this.input[this.position];this.position++;const n=this.readUntil(new RegExp(`${i}`));e[t]=n,this.position++}return"/"===this.input[this.position]&&this.position++,this.position++,{type:"StartTag",name:t,attributes:e}}readEndTag(){this.position+=2;const t=this.readUntil(">");return this.position++,{type:"EndTag",name:t}}readComment(){this.position+=4;const t=this.readUntil("--\x3e");return this.position+=3,{type:"Comment",value:t}}readText(){return{type:"Text",value:this.readUntil("<")}}readUntil(t){const e=this.position;for(;this.position<this.input.length&&!("string"==typeof t?this.input[this.position]===t:t.test(this.input[this.position]));)this.position++;return this.input.slice(e,this.position)}}class n{namespaceRules={html:["html","head","body","title","meta","link","p","div","a","img","media"]};attributeRules={"html:a":["href","title"],"html:img":["src","alt","width","height"],"html:media":["src","type","controls","autostart"]};validationCache=new Map;registerNamespace(t,e){this.namespaceRules[t]=e}registerAttributes(t,e){this.attributeRules[t]=e}validateAST(t){const e=this.getCacheKey(t);if(this.validationCache.has(e))return this.validationCache.get(e);const i=[];this.traverseAST(t,i);const n={valid:0===i.length,errors:i};return this.validationCache.set(e,n),n}traverseAST(t,e){"Element"===t.type&&this.validateElement(t,e);for(const i of t.children)this.traverseAST(i,e)}validateElement(t,e){if(!t.name)return;const[i,n]=t.name.split(":");if(this.namespaceRules[i]?this.namespaceRules[i].includes(n)||e.push(`Invalid tag <${t.name}> in namespace ${i}`):e.push(`Unknown namespace: ${i} in <${t.name}>`),t.attributes)for(const[i,n]of Object.entries(t.attributes)){(this.attributeRules[t.name]||[]).includes(i)||e.push(`Invalid attribute "${i}" on <${t.name}>`)}}getCacheKey(t){return JSON.stringify(t,((t,e)=>"parent"===t?void 0:e))}}function r(t){return"Element"===t.type}class s extends Error{token;position;constructor(t,e,i){super(t),this.name="HTMLParserError",this.token=e,this.position=i,Error.captureStackTrace&&Error.captureStackTrace(this,s)}}exports.AST=t,exports.ASTOptimizer=class{optimize(t){return this.removeEmptyNodes(t),this.mergeTextNodes(t),t}removeEmptyNodes(t){t.children=t.children.filter((t=>("Text"!==t.type||""!==t.value?.trim())&&(!("Element"===t.type&&0===t.children.length&&!this.isSelfClosingTag(t.name))&&(this.removeEmptyNodes(t),!0))))}mergeTextNodes(t){let e=0;for(;e<t.children.length-1;){const i=t.children[e],n=t.children[e+1];"Text"===i.type&&"Text"===n.type?(i.value=(i.value||"")+(n.value||""),t.children.splice(e+1,1)):(this.mergeTextNodes(i),e++)}}isSelfClosingTag(t){return["img","input","br","hr","meta","link"].includes(t||"")}},exports.CodeGenerator=class{generateHTML(t){if("Text"===t.type)return t.value||"";if("Comment"===t.type)return`\x3c!-- ${t.value} --\x3e`;if("Element"===t.type){const e=this.generateAttributes(t.attributes||{}),i=t.children.map((t=>this.generateHTML(t))).join("");return this.isSelfClosingTag(t.name)?`<${t.name}${e} />`:`<${t.name}${e}>${i}</${t.name}>`}return""}generateAttributes(t){return Object.entries(t).map((([t,e])=>` ${t}="${e}"`)).join("")}isSelfClosingTag(t){return["img","input","br","hr","meta","link"].includes(t||"")}},exports.HTMLParser=class{tokenizer;astBuilder;validator;errorHandler=null;shouldThrow=!0;constructor(e={throwOnError:!0}){this.tokenizer=new i(""),this.astBuilder=new t,this.validator=new n,this.shouldThrow=e.throwOnError}setErrorHandler(t){this.errorHandler=t,this.shouldThrow=!1}handleError(t,e=!1){if(this.errorHandler)this.errorHandler(t);else{if(this.shouldThrow)throw t;e||(console.error(`Error at position ${t.position}: ${t.message}`),console.error(`Problematic token: ${JSON.stringify(t.token)}`))}}isWhitespace(t){return/^\s*$/.test(t)}parse(t){this.tokenizer=new i(t);const e=this.tokenizer.tokenize(),n=this.buildASTWithRecovery(e);return this.cleanWhitespace(n),n}cleanWhitespace(t){t.children&&(t.children.forEach((t=>this.cleanWhitespace(t))),t.children=t.children.filter((t=>!function(t){return"Text"===t.type}(t)||!this.isWhitespace(t.value))))}buildASTWithRecovery(t){const e=this.astBuilder.getRoot(),i=[e];let n=e,o=null;for(let e=0;e<t.length;e++){const a=t[e];if(o&&"EndTag"===a.type&&a.name===o)o=null;else if(!o)try{switch(a.type){case"StartTag":{const t={type:"Element",name:a.name,attributes:a.attributes,children:[],parent:n};n.children.push(t),i.push(t),n=t;break}case"EndTag":{const t=i.findIndex((t=>t.name===a.name));if(-1===t)throw new s(`Unmatched end tag: </${a.name}>. Expected </${r(n)?n.name:"unknown"}>.`,a,e);for(;i.length>t;)i.pop();n=i[i.length-1];break}case"Text":{const t={type:"Text",value:a.value,children:[],parent:n};n.children.push(t);break}case"Comment":{const t={type:"Comment",value:a.value,children:[],parent:n};n.children.push(t);break}}}catch(t){if(t instanceof s){if(this.handleError(t),!this.shouldThrow){r(n)&&(o=n.name);continue}throw t}throw t}}for(;i.length>1;){const e=i.pop();this.handleError(new s(`Unclosed tag: <${e.name}>`,{type:"StartTag",name:e.name,attributes:{}},t.length),!0)}return e}},exports.HTMLParserError=s,exports.HTMLTokenizer=i,exports.Validator=n;
//# sourceMappingURL=index.cjs.map
